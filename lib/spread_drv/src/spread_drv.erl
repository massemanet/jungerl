%%%----------------------------------------------------------------------
%%% File    : spread_drv.erl
%%% Summary : Spread toolkit version 3.17.0 driver
%%%
%%%
%%% NOTICE: This file was generated by the tools of the Erlang Driver
%%%         toolkit.  Do not edit this file by hand unless you know
%%%         what you're doing!
%%%
%%% Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
%%% See the file "LICENSE" at the top of the source distribution for
%%% full license terms.
%%%
%%%----------------------------------------------------------------------

-module(spread_drv).
-include("spread_drv.hrl").

%% Xref with erl_driver_tk.h's PIPE_DRIVER_TERM_* values
-define(T_NIL, 0).
-define(T_ATOM, 1).
-define(T_PORT, 2).
-define(T_INT, 3).
-define(T_TUPLE, 4).
-define(T_BINARY, 5).
-define(T_STRING, 6).
-define(T_LIST, 7).

%% External exports

-export([shutdown/1]).
-export([make_grouplist/1]).
 
-export([start/0, start_pipe/0]).
-export([debug/2]).
-export([
         sp_connect/5, 
         sp_disconnect/1, 
         sp_join/2, 
         sp_leave/2, 
         sp_multicast/5, 
         sp_multigroup_multicast/5, 
         sp_poll/1, 
         sp_receive/3, 
         sp_get_gid_offset_memb_mess/1, 
         sp_get_num_vs_offset_memb_mess/1, 
         sp_get_vs_set_offset_memb_mess/1, 
         set_active/2
        ]).

start() ->
    {ok, Path} = load_path(?DRV_NAME ++ ".so"),
    erl_ddll:start(),
    ok = erl_ddll:load_driver(Path, ?DRV_NAME),
    case open_port({spawn, ?DRV_NAME}, []) of
        P when port(P) ->
            {ok, P};
        Err ->
            Err
    end.

start_pipe() ->
    {ok, PipeMain} = load_path("pipe-main"),
    {ok, ShLib} = load_path("./spread_drv.so"),
    Cmd = PipeMain ++ "/pipe-main " ++ ShLib ++ "/spread_drv.so",
    case open_port({spawn, Cmd}, [exit_status, binary, use_stdio, {packet, 4}]) of
        P when port(P) ->
            {ok, P};
        Err ->
            Err
    end.


debug(Port, Flags) when port(Port), integer(Flags) ->
    case catch erlang:port_command(Port, <<?_DEBUG, Flags:32>>) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX too drastic?
    end.

sp_connect(Port,
     Spread_Name, 
     Private_Name, 
     Priority, 
     Group_Membership
        ) when port(Port) -> % TODO: Add additional constraints here
    {Spread_NameBinOrList, Spread_NameLen} = serialize_contiguously(Spread_Name, 1),
    {Private_NameBinOrList, Private_NameLen} = serialize_contiguously(Private_Name, 1),
    IOList_____ = [ <<?_SP_CONNECT,
            Spread_NameLen:32/integer>>,        % I/O list length
          Spread_NameBinOrList,
          <<
            Private_NameLen:32/integer>>,       % I/O list length
          Private_NameBinOrList,
          <<
          Priority:32/integer, 
          Group_Membership:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_disconnect(Port
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_DISCONNECT>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_join(Port,
     Group
        ) when port(Port) -> % TODO: Add additional constraints here
    {GroupBinOrList, GroupLen} = serialize_contiguously(Group, 1),
    IOList_____ = [ <<?_SP_JOIN,
            GroupLen:32/integer>>,              % I/O list length
          GroupBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_leave(Port,
     Group
        ) when port(Port) -> % TODO: Add additional constraints here
    {GroupBinOrList, GroupLen} = serialize_contiguously(Group, 1),
    IOList_____ = [ <<?_SP_LEAVE,
            GroupLen:32/integer>>,              % I/O list length
          GroupBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_multicast(Port,
     Service_Type, 
     Group, 
     Mess_Type, 
     Mess
        ) when port(Port) -> % TODO: Add additional constraints here
    {GroupBinOrList, GroupLen} = serialize_contiguously(Group, 1),
    {MessBinOrList, MessLen} = serialize_contiguously(Mess, 0),
    IOList_____ = [ <<?_SP_MULTICAST,
          Service_Type:32/unsigned-integer, 
            GroupLen:32/integer>>,              % I/O list length
          GroupBinOrList,
          <<
          Mess_Type:16/unsigned-integer, 
            MessLen:32/integer>>,               % I/O list length
          MessBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_multigroup_multicast(Port,
     Service_Type, 
     Groups, 
     Mess_Type, 
     Mess
        ) when port(Port) -> % TODO: Add additional constraints here
    {GroupsBinOrList, GroupsLen} = serialize_contiguously(Groups, 0),
    {MessBinOrList, MessLen} = serialize_contiguously(Mess, 0),
    IOList_____ = [ <<?_SP_MULTIGROUP_MULTICAST,
          Service_Type:32/unsigned-integer, 
            GroupsLen:32/integer>>,             % I/O list length
          GroupsBinOrList,
          <<
          Mess_Type:16/unsigned-integer, 
            MessLen:32/integer>>,               % I/O list length
          MessBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_poll(Port
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_POLL>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_receive(Port,
     Max_Groups, 
     Max_Mess_Len
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_RECEIVE,
          Max_Groups:32/integer, 
          Max_Mess_Len:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_get_gid_offset_memb_mess(Port
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_GET_GID_OFFSET_MEMB_MESS>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_get_num_vs_offset_memb_mess(Port
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_GET_NUM_VS_OFFSET_MEMB_MESS>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

sp_get_vs_set_offset_memb_mess(Port
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SP_GET_VS_SET_OFFSET_MEMB_MESS>>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

set_active(Port,
     Value
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_SET_ACTIVE,
          Value:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % XXX Is this too drastic?
    end.

    
%%%
%%% Internal functions.
%%%

load_path(File) ->
    case lists:filter(fun(D) ->
                              case file:read_file_info(D ++ "/" ++ File) of
                                  {ok, _} -> true;
                                  _ -> false
                              end
                      end, code:get_path()) of
        [Dir|_] ->
            {ok, Dir};
        [] ->
            io:format("Error: ~s not found in code path\n", [File]),
            {error, enoent}
    end.

%%%
%%% Note that an 'xtra_return' that only returns one item in its
%%% tuple will return {Port, ok, {Thingie}}, so we'll return
%%% {ok, {Thingie}}, which is *sooooooo* maddening because I keep
%%% forgetting the extra tuple wrapper.  So, if there's only one
%%% thingie in the return tuple, strip it off: {ok, Thingie}
%%%

get_port_reply(Port) when port(Port) ->
    receive
        {Port, ok} = T -> proc_reply(T);
        {Port, ok, {M}} = T -> proc_reply(T);
        {Port, ok, M} = T -> proc_reply(T);
        {Port, error, {Reason}} = T -> proc_reply(T);
        {Port, error, Reason} = T -> proc_reply(T);
        %% Pipe driver messages
        {Port, {data, Bytes}} -> proc_reply(pipedrv_deser(Port, Bytes));
        {'EXIT', Port, Reason} -> throw({port_error, Reason});  % XXX too drastic?
        {Port, Reason} -> throw({port_error, Reason})   % XXX too drastic?
    end.

%% This function exists to provide consistency of replies 
%% given by linked-in and pipe drivers.  The "receive" statement
%% in get_port_reply/1 is specific because we want it to be
%% very selective about what it will grab out of the mailbox.
proc_reply({Port, ok}) when port(Port) ->
    ok;
proc_reply({Port, ok, {M}}) when port(Port) ->
    {ok, M};
proc_reply({Port, ok, M}) when port(Port) ->
    {ok, M};
proc_reply({Port, error, {Reason}}) when port(Port) ->
    {error, Reason};
proc_reply({Port, error, Reason}) when port(Port) ->
    {error, Reason}.


%%% io_list_len() is an extremely useful function.  BEAM has got this
%%% implemented quite efficiently in C.  It would be *fabulous* to be able
%%% to use it from Erlang via a BIF.

io_list_len(B) when binary(B) -> {B, size(B)};
io_list_len(L) when list(L) -> io_list_len(L, 0).
io_list_len([H|T], N) ->
    if
        H >= 0, H =< 255 -> io_list_len(T, N+1);
        list(H) -> io_list_len(T, io_list_len(H,N));
        binary(H) -> io_list_len(T, size(H) + N);
        true -> throw({error, partial_len, N})
    end;
io_list_len(H, N) when binary(H) -> 
    size(H) + N;
io_list_len([], N) -> 
    N.

%%% We need to make the binary thing we're passing in contiguous
%%% because the C function we're calling is expecting a single
%%% contiguous buffer.  If IOList is ["Hello, ", <<"World">>, "!"],
%%% that binary in the middle element will end up with the argument
%%% spanning three parts of an ErlIOVec.  If that happens, then we'd
%%% have to have the driver do the dirty work of putting the argument
%%% into a single contiguous buffer.
%%%
%%% Frankly, we're lazy, and this code is short and won't be much
%%% slower than doing it in C.

%%% 2nd arg: if 1, NUL-terminate the IOList

serialize_contiguously(B, 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously([B], 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously(IOList, 1) ->
    serialize_contiguously([IOList, 0], 0);
serialize_contiguously(IOList, 0) ->
    B = list_to_binary(IOList),
    {B, size(B)}.


%% pipedrv_deser/2 -- Deserialize the term that the pipe driver is
%% is returning to Erlang.  The pipe driver doesn't know it's a pipe
%% driver, it thinks it's a linked-in driver, so it tries to return
%% an arbitrary Erlang term to us.  The pipe-main program is sneaky:
%% it has a driver_output_term() function that serializes the term
%% that the driver built.  With the help of a list-as-stack, we
%% deserialize that term.

pipedrv_deser(Port, B) ->
    pipedrv_deser(Port, B, []).

pipedrv_deser(Port, <<>>, []) ->
    throw(icky_i_think);
pipedrv_deser(Port, <<>>, [T]) ->
    T;
pipedrv_deser(Port, <<?T_NIL:8, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [foo___foo_nil___|Stack]);
pipedrv_deser(Port, <<?T_ATOM:8, Len:8, Rest/binary>>, Stack) ->
    <<A:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [list_to_atom(binary_to_list(A))|Stack]);
pipedrv_deser(Port, <<?T_PORT:8, P:32/unsigned, Rest/binary>>, Stack) ->
    %% The pipe driver tried sending us a port, but it cannot know what
    %% port ID was assigned to this port, so we'll assume it is Port.
    pipedrv_deser(Port, Rest, [Port|Stack]);
pipedrv_deser(Port, <<?T_INT:8, I:32/signed, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [I|Stack]);
pipedrv_deser(Port, <<?T_TUPLE:8, N:8, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [list_to_tuple(L)|NewStack]);
pipedrv_deser(Port, <<?T_LIST:8, N:32, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [L|NewStack]);
pipedrv_deser(Port, <<?T_BINARY:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [Bin|Stack]);
pipedrv_deser(Port, <<?T_STRING:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [binary_to_list(Bin)|Stack]);
pipedrv_deser(Port, X, Y) ->
    throw({bah, X, Y}).

popN(N, Stack) ->
    popN(N, Stack, []).
popN(0, Stack, Acc) ->
    {Acc, Stack};
popN(N, [foo___foo_nil___|T], Acc) ->
    %% This is the nonsense we put on the stack to represent NIL.  Ignore it.
    popN(N - 1, T, Acc);
popN(N, [H|T], Acc) ->
    popN(N - 1, T, [H|Acc]).


%%%
%%% Begin code included via <custom_erl> tags
%%%


shutdown(Port) ->
    case catch port_close(Port) of
         true -> ok;
         _ -> error
    end,
    ok.

%%
%% make_grouplist() -- Use to format the group list for
%% sp_multigroup_multicast().  The members of the list NUL-terminated
%% and concatenated.  If the first byte of a member name is NUL, then
%% you've reached the end of the list.
%%
%% QQQ We are very trusting about our input: no empty lists or
%% binaries as list members, no list members with NULs in them, etc.
%%
make_grouplist(L) ->
    list_to_binary(make_grouplist2(L)).

make_grouplist2([]) ->
    [0];
make_grouplist2([H|T]) ->
    [H | [0 | make_grouplist2(T)]].

 

