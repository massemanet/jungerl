How to use the Jungerl
======================================================================

Simple! You just do 'make' to build all the erlang programs.

If you want, you can add the bin/ directory to your $PATH, and use the
useful program(s) in there!

If a program is giving you trouble, just put a file called SKIP in its
top-level directory. For example, if you want to skip the 'tuntap'
program, do:  touch lib/tuntap/SKIP


How to add an application to the Jungerl
======================================================================

Each application has its own directory called lib/<appname>.

The absolute minimum requirement for an application is to have a
Makefile in the lib/<appname> directory with three targets:

  'all' should build the program.

  'clean' should delete any object files.

  'config' should do any necessary configuration. Most likely this is
  nothing, but it can be used for e.g. application-specific autoconf
  scripts.

Realistically, your lib/<appname>/ dir should also have any of these
subdirectories that are appropriate:

  src/   containing erlang sources

  ebin/  containing beam files

  c_src/ containing C sources

  priv/  containing files you want at runtime (e.g. built from c_src)

  doc/   (not sure what this is for..)

Once you have created your application, you should edit the top level
Makefile like this:

  Add your <appname> to the "LIBS" variable.

  If you depend on other applications, add a line that says so. For
  example <none yet..>.


Makefile Helpers
----------------------------------------------------------------------

The support/ directory contains a couple of useful include files for
your Makefiles:

  subdirs.mk: Intended for your lib/<appname>/ directory, this defines
  targets for 'all', 'clean', and 'config' that just cd into
  $(SUBDIRS) (by default c_src and src) and does the same "make" in
  each of them.

  include.mk: This defines a bunch of useful things for building C and
    Erlang programs. For C it has 'configure'-detected CC and CFLAGS
    variables, and ERL_C_INCLUDE_DIR for
    <prefix>/lib/erlang/usr/include/ (e.g. for writing drivers)

    For Erlang it has a 'configure'-detected ERLC, an
    automatically-detected list of beam files to build (../ebin/*.beam
    for all *.erl files) called ERL_OBJECTS, and
    automatically-detected list of headers they depend on (*.hrl and
    ../include/*.hrl) called ERL_HEADERS, and an implicit rule for
    building ../ebin/*.beam from *.erl.

That probably wasn't very clear, but if you look at how the 'tuntap'
program's Makefiles are done then it should be obvious.

