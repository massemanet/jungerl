/*
** Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
** See the file "LICENSE" at the top of the source distribution for
** full license terms.
**
** NOTICE: This file was generated by the tools of the Erlang Driver
**         toolkit.  Do not edit this file by hand unless you know
**         what you're doing!
**
*/

#ifndef __SPREAD_DRV_H
#define __SPREAD_DRV_H

#ifdef   DRIVER_USING_PTHREADS
#include <pthread.h>
#endif   /* DRIVER_USING_PTHREADS */

/*
** Driver<->emulator communication codes (xref with top of spread_drv.hrl)
*/

#define _DEBUG                          0
#define _SP_CONNECT                     1
#define _SP_DISCONNECT                  2
#define _SP_JOIN                        3
#define _SP_LEAVE                       4
#define _SP_MULTICAST                   5
#define _SP_MULTIGROUP_MULTICAST        6
#define _SP_POLL                        7
#define _SP_RECEIVE                     8
#define _SP_GET_GID_OFFSET_MEMB_MESS    9
#define _SP_GET_NUM_VS_OFFSET_MEMB_MESS  10
#define _SP_GET_VS_SET_OFFSET_MEMB_MESS  11
#define _SET_ACTIVE                     12

/*
** Constants
*/

#ifndef MAX_MULTIGROUPS
#define MAX_MULTIGROUPS  64    /* Max number of groups in a multi-group multicast message */
#endif
#ifndef MAX_MSGLEN
#define MAX_MSGLEN      (99*1024)    /* Max length of a multicast message */
#endif

#define  MAX_BINVS              24      /* XXX dumb constant! */

#define  VALMAP_INUSE           0x01
#define  VALMAP_DELAYED_CLEANUP 0x02

#define  MAX_RETURN_TERMS       64

/*
** descriptor_t = general state for the port
**
*/

struct descriptor {
    ErlDrvPort          port;
    unsigned short      nextxid;        /* Call txn ID for very async calls */
    pthread_mutex_t     mutex;  /* Protect access to valmap flags */
/* <verbatim place="descriptor_members"> */

        int     mbox_init_p;    /* Flag: mailbox is initialized */
        mailbox mbox;
        char    private_group[MAX_GROUP_NAME];
        char    sender[MAX_GROUP_NAME];
        int     active_p;       /* Flag: "active" behavior enabled */

/* </verbatim --place="descriptor_members"--> */
    ErlDrvBinary        *tofree[MAX_RETURN_TERMS];
    int                 num_tofree;
};

/*
** callstate_t: asychronous call state
**
** TODO: Fill in the struct members of "i" and "o" below.
*/
typedef struct callstate {
    struct callstate    *next;
    int                 cmd;            /* call/command # */
    unsigned int        *key;           /* Not really used */
    void                (*invoke)(void *);
    void                (*free)(void *);
    unsigned short      xid;            /* Only used by as_control()-
                                           initiated funcs */
    struct descriptor   *desc;
    int                 refc_bincount;
    ErlDrvBinary        *refc_bin[MAX_BINVS];
    /*
    ** Input & output args use a struct simply for convenient
    ** naming & grouping.  There isn't any attempt to get smart about
    ** using a union or anything like that to avoid bloating the size
    ** of these structs with the combined args of a zillion different
    ** functions.  XXX For future use: look into the use of unions
    ** and/or different flavors of callstate_t to avoid structure bloat.
    */
    struct {
        unsigned long   __stash[4];
        char *          spread_name;
        char *          private_name;
        int             priority;
        int             group_membership;
        mailbox *       mbox_ptr;
        char *          private_group;
        mailbox         mbox;
        char *          group;
        service         service_type;
        int16           mess_type;
        int             mess_len;
        char *          mess;
        char *          groups;
        char *          sender;
        int             max_groups;
        int             max_mess_len;
        ErlDrvData      drv_data;
        int             value;
    } i;
    struct {
        int             __expect;
        int             __expect_errval;
        int             ret_int;
        service         service_type;
        int             num_groups;
        int16           mess_type;
        int             endian_mismatch;
    } o;
} callstate_t;

/*
** End of autogenerated code
**  script = ../../edtk/c_h_template.gsl
**  filename = spread.xml
**  gslgen version = 2.000 Beta 1
**  date = 2003/05/20
**  time =  0:49:28
*/

#endif  /* __SPREAD_DRV_H */
