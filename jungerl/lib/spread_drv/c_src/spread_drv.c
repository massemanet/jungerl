/*
** File    : spread_drv.c
** Summary : Spread toolkit version 3.17.0 driver
** 
** NOTICE: This file was generated by the tools of the Erlang Driver
**         toolkit.  Do not edit this file by hand unless you know
**         what you're doing!
** 
** Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
** See the file "LICENSE" at the top of the source distribution for
** full license terms.
*/

/*
** XXX Before I forget yet again to write this down...
**
** ... the valmap ID assignment has a weakness that should be fixed
** sometime in the future.  The weakness is that reusing the array
** indexes could result in Erlang being able to access a later
** incarnation of a valmap table entry by simply remembering a
** previous valmap {valmap_blah, Integer} and resending it to the
** driver, hoping to get (un)lucky.  
**
** The solution would be to choose a valmap index from a larger, very
** unlikely to repeat set, and use a mapping data structure less naive
** than a dumb array.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <assert.h>
#ifdef   DRIVER_USING_PTHREADS
#include <pthread.h>
#else    /* DRIVER_USING_PTHREADS */
#define  pthread_self()         0
#endif   /* DRIVER_USING_PTHREADS */

/* TODO: Add additional system & local header file #includes */

#include <erl_driver.h>
#include <erl_driver_tk.h>

/* <verbatim place="top_cpp_stuff"> */

#include <stdio.h>
#include <string.h>

#include <sp.h>
#include <spread_drv.h>
#include <my-spread.h>

/* </verbatim --place="top_cpp_stuff"--> */

/* Last, but not least.... */
#include <spread_drv.h>


static ErlDrvTermData am_ok;
static ErlDrvTermData am_error;
static ErlDrvTermData am_badarg;
static ErlDrvTermData am_enomem;
static ErlDrvTermData am_unknown;

static int default_async_calls = 1;

/* This variable may be set only by pipe-main! */
int pipe_driver_p = 0;

/*
** TODO: Define any other Erlang terms this driver may return.
*/

/* Function prototypes */

ErlDrvEntry *driver_init(void *);       /* Do not change name! */
static int _init(void);
static ErlDrvData _start(ErlDrvPort port, char *command);
static void _stop(ErlDrvData drv_data);
static void _output(ErlDrvData drv_data, char *buf, int len);
static void _ready_input(ErlDrvData drv_data, ErlDrvEvent event);
static int _control(ErlDrvData drv_data, unsigned int command, char *buf, int len, char **rbuf, int rlen);
static void _outputv(ErlDrvData drv_data, ErlIOVec *ev);
static void _ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data);

void *sys_alloc(size_t);
void *sys_realloc(void *, size_t);
void sys_free(void *);

static void invoke__sp_connect(void *data);
static void invoke__sp_disconnect(void *data);
static void invoke__sp_join(void *data);
static void invoke__sp_leave(void *data);
static void invoke__sp_multicast(void *data);
static void invoke__sp_multigroup_multicast(void *data);
static void invoke__sp_poll(void *data);
static void invoke__sp_receive(void *data);
static void invoke__sp_get_gid_offset_memb_mess(void *data);
static void invoke__sp_get_num_vs_offset_memb_mess(void *data);
static void invoke__sp_get_vs_set_offset_memb_mess(void *data);
static void invoke__set_active(void *data);

static int reply_xtra_xret_connect(descriptor_t *, callstate_t *);
static int reply_xtra_xret_receive(descriptor_t *, callstate_t *);


static int reply_ok(descriptor_t *desc);
static int reply_ok_num(descriptor_t *desc, unsigned long num);
static int reply_ok_binary(descriptor_t *desc, char *p, int, int);
static int reply_ok_valmap(descriptor_t *, ErlDrvTermData, unsigned long);
static int reply_error(descriptor_t *desc, int errnum);
static int reply_error_atom(descriptor_t *, ErlDrvTermData);
#if     0
static int reply_tag_ok(descriptor_t *desc, unsigned short tag);
static int reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum);
#endif  /* 0 */

static ErlDrvEntry _driver_entry = {
    _init,                      /* init */
    _start,                     /* start */
    _stop,                      /* stop */
    _output,                    /* output */
    _ready_input,               /* ready_input */
    NULL,                       /* ready_output */
    "spread_drv",               /* driver_name */
    NULL,                       /* finish */
    NULL,                       /* handle */
    _control,                   /* control */
    NULL,                       /* timeout */
    _outputv,                   /* outputv */
    _ready_async,               /* ready_async */
    NULL,                       /* flush */
    NULL                        /* call */
};

/*
** All dynamically-loadable driver libraries must contain a driver_init().
*/

ErlDrvEntry *
driver_init(void *handle)
{
    edtk_debug_flag = 0;
    _driver_entry.handle = handle;
    return &_driver_entry;
}

static int
_init(void)
{
    am_ok = driver_mk_atom("ok");
    am_error = driver_mk_atom("error");
    am_badarg = driver_mk_atom("badarg");
    am_enomem = driver_mk_atom("enomem");
    am_unknown = driver_mk_atom("unknown");

    /* TODO: Take care of other first-time initialization tasks */

    return 0;
}

static ErlDrvData
_start(ErlDrvPort port, char *args)
{
    descriptor_t        *desc;
    int                 i = 0;

    i = i;
    edtk_debug("%s: starting, port = %ld, args = 0x%lx, %s", __FUNCTION__,
               port, (unsigned long) args, args);

    if ((desc = (descriptor_t *) sys_alloc(sizeof(descriptor_t))) == NULL) {
        return ERL_DRV_ERROR_GENERAL;
    }
    memset(desc, 0, sizeof(descriptor_t));
    desc->port = port;
    desc->nextxid = 1;
    pthread_mutex_init(&desc->mutex, NULL);
    /* TODO: Finish initializing descriptor members */

    /* TODO: Take care of other port initialization tasks */

    return (ErlDrvData) desc;
}

static void
_stop(ErlDrvData drv_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    int                 i = 0;
    ErlDrvPort          port;
    int                 still_in_use = 0;

    i = i;
    if (desc == NULL) {
        edtk_debug("%s: drv_data == NULL", __FUNCTION__);
        return;
    }
    edtk_debug("%s: port = %ld", __FUNCTION__, desc->port);


    if (! still_in_use) {
/* <verbatim place="end-driver-stop"> */

        if (desc->active_p) {
                driver_select(desc->port, (ErlDrvEvent) desc->mbox, DO_READ, 0);
        }
        if (desc->mbox_init_p) {
                edtk_debug("%s: port stop: calling SP_disconnect", __FUNCTION__);
                SP_disconnect(desc->mbox);
                edtk_debug("%s: port stop: SP_disconnect done", __FUNCTION__);
                desc->mbox_init_p = 0;
        }

/* </verbatim --place="end-driver-stop"--> */
        port = desc->port;
        sys_free(desc);    
        edtk_debug("%s: port = %ld finished", __FUNCTION__, port);
    } else {
        /*
        ** XXX Oi, this is a sticky problem.  This port is being shut
        ** down, but we've still got some valmaps in use.  We have no
        ** way to tell the VM that we cannot be shut down safely right
        ** now, so what in the heck do we do?  It seems to me that we
        ** have two choices:
        **   1. Block the entire VM until all valmaps are idle, then
        **      clean them up and then return.
        **   2. Create a new thread that will take care of monitoring
        **      the valmaps & doing their final cleanup.  This stop
        **      function, executing in the main thread, can return
        **      to the VM right away.
        ** For the sake of simplicity, I'm going to implement #1
        ** for now.  This will get more complicated once EDTK supports
        ** private worker threads, so we won't bother getting fancy
        ** for now.
        */
        edtk_debug("%s: port = %ld has %d valmaps still in use!", __FUNCTION__, desc->port, still_in_use);
        sleep(1);
        _stop(drv_data);                /* Hope we don't run out of stack */
    }
}

static void
_output(ErlDrvData drv_data, char *buf, int len)
{
    /*
    ** Nobody should be calling this function because we've
    ** defined the "outputv" driver method, which BEAM will always
    ** used if it's available.  I just put a debug statement in
    ** here so that I might actually notice if the impossible ever
    ** happens....
    */
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
}

static void
_ready_input(ErlDrvData drv_data, ErlDrvEvent event)
{
    edtk_debug("%s: XXX top", __FUNCTION__);
    my_ready_input(drv_data, event);
}

static int
_control(ErlDrvData drv_data, unsigned int command,
                  char *buf, int len, char **rbuf, int rlen)
{
    char        *ret = *rbuf;
    int         retlen;

    /*
    ** Nobody should be calling this function either.
    */
    ret[0] = 1;
    retlen = 1;
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
    return retlen;
}

static void
_outputv(ErlDrvData drv_data, ErlIOVec *ev)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    unsigned char       cmd;
    int                 p = 0, q = 1;
    callstate_t         *c = NULL;
    int                 do_async_call = default_async_calls;
    unsigned long       binlen;
    int                 index;
    void                *tmp = NULL;

    binlen = binlen;
    index = index;
    tmp = tmp;
    if (desc == NULL || ev == NULL || ev->size < 1) {
        edtk_debug("%s: bad arg(s)", __FUNCTION__);
        return;
    }
    if (! EV_GET_CHAR(ev, &cmd, &p, &q)) {
        edtk_debug("%s: empty command", __FUNCTION__);
        reply_error(desc, EINVAL);
    }
    if ((c = sys_alloc(sizeof(callstate_t))) == NULL) {
        reply_error(desc, ENOMEM);
        return;
    }
    c->cmd = cmd;
    c->key = NULL;
    c->free = sys_free;
    c->xid = 0;         /* XXX unused right now */
    c->o.__expect = 1;  /* Default is that expectation is always met */
    c->desc = desc;
    c->refc_bincount = 0;

    edtk_debug("%s: my threadid = %lx, cmd = %d", __FUNCTION__, pthread_self(), cmd);
    switch (cmd) {
    case _DEBUG:
        EV_GET_UINT32(ev, &edtk_debug_flag, &p, &q);
        reply_ok_num(desc, edtk_debug_flag);    /* Immediate reply */
        sys_free(c);
        c = NULL;
        break;
    case _SP_CONNECT:
        c->invoke = invoke__sp_connect;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.spread_name = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.private_name = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.priority, &p, &q);
        EV_GET_UINT32(ev, &c->i.group_membership, &p, &q);
        /* <hack place="post-deserialize" type="verbatim"> */

        if (desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: already connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        if (strlen(c->i.private_name) == 0) {
                c->i.private_name = NULL;
        }
        c->i.mbox_ptr = &desc->mbox;
        c->i.private_group = &desc->private_group[0];
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_DISCONNECT:
        c->invoke = invoke__sp_disconnect;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        /* <hack place="post-deserialize" type="verbatim"> */

        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_JOIN:
        c->invoke = invoke__sp_join;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.group = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_LEAVE:
        c->invoke = invoke__sp_leave;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.group = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_MULTICAST:
        c->invoke = invoke__sp_multicast;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &c->i.service_type, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.group = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT16(ev, &c->i.mess_type, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.mess = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_MULTIGROUP_MULTICAST:
        c->invoke = invoke__sp_multigroup_multicast;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &c->i.service_type, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.groups = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT16(ev, &c->i.mess_type, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.mess = (char *) EV_GETPOS(ev, p, q);
        if (do_async_call) {
            if (c->refc_bincount == MAX_BINVS) {
                goto error;
            }
            ev->binv[q]->refc++;
            c->refc_bin[c->refc_bincount++] = ev->binv[q];
        }
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_POLL:
        c->invoke = invoke__sp_poll;
        do_async_call =  0;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->i.mbox = desc->mbox;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_RECEIVE:
        c->invoke = invoke__sp_receive;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &c->i.max_groups, &p, &q);
        EV_GET_UINT32(ev, &c->i.max_mess_len, &p, &q);
        /* <hack place="post-deserialize" type="verbatim"> */

        if (! desc->mbox_init_p) {
                edtk_debug("%s: sp_connect: not connected", __FUNCTION__);
                reply_error(desc, ILLEGAL_SESSION);
                return;
        }
        c->o.service_type = 0; /* Avoid DROP_RECV semantics with zero! */
        c->i.mbox = desc->mbox;
        c->i.sender = &desc->sender[0];  /* static allocation hack */
        if ((c->i.groups = (char *) sys_alloc(c->i.max_groups * MAX_GROUP_NAME)) == NULL) {
                edtk_debug("%s: sp_receive: sys_alloc failed", __FUNCTION__);
                reply_error(desc, ENOMEM);
                return;
        }
        if ((c->i.mess = (char *) edtk_driver_alloc_wrapper(c->i.max_mess_len)) == NULL) {
                edtk_debug("%s: sp_receive: edtk_driver_alloc_wrapper failed", __FUNCTION__);
                free(c->i.groups);
                reply_error(desc, ENOMEM);
                return;
        }
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _SP_GET_GID_OFFSET_MEMB_MESS:
        c->invoke = invoke__sp_get_gid_offset_memb_mess;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        break;
    case _SP_GET_NUM_VS_OFFSET_MEMB_MESS:
        c->invoke = invoke__sp_get_num_vs_offset_memb_mess;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        break;
    case _SP_GET_VS_SET_OFFSET_MEMB_MESS:
        c->invoke = invoke__sp_get_vs_set_offset_memb_mess;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        break;
    case _SET_ACTIVE:
        c->invoke = invoke__set_active;
        /* Do not ever do async call if we're in pipe driver mode */
        do_async_call =  pipe_driver_p ? 0 : do_async_call;
        EV_GET_UINT32(ev, &c->i.value, &p, &q);
        /* <hack place="post-deserialize" type="verbatim"> */

        c->i.drv_data = drv_data;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
     default:
        edtk_debug("%s: invalid command %d", __FUNCTION__, cmd);
        goto error;
        break;  
    }
    if (c != NULL) {
        if (do_async_call) {
            driver_async(desc->port, c->key, c->invoke, c, c->free);
        } else {
            /*
            ** Execute the bottom half right away, then send the result.
            */
            (*(c->invoke))((void *) c);
            _ready_async((ErlDrvData) desc, (ErlDrvThreadData) c);
            /* 
            ** c is already freed for us by _ready_async()
            */
        }
    }
    return;

  error:
    if (c != NULL) {
        sys_free(c);
    }
    reply_error_atom(desc, am_badarg);
}

static void
_ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    callstate_t *c = (callstate_t *) thread_data;
    int                 bytes, offset, i;
    char                *p = NULL;
    unsigned long       index = 0;

    p = p;
    bytes = bytes;
    offset = offset;
    i = i;
    index = index;
    edtk_debug("%s: cmd = %d", __FUNCTION__, c->cmd);
    if (c == NULL) {
        edtk_debug("%s: c == NULL", __FUNCTION__);
        return;
    }
    switch (c->cmd) {
    case _SP_CONNECT:
        /* <hack place="ready_async-pre-reply" type="verbatim"> */

        if (c->o.ret_int == ACCEPT_SESSION) {
                desc->mbox_init_p = 1;
        }
 
        /* </hack --place="ready_async-pre-reply" type="verbatim"--> */
        reply_xtra_xret_connect(desc, c);
        break;
    case _SP_DISCONNECT:
        /* <hack place="ready_async-pre-reply" type="verbatim"> */

        if (c->o.ret_int == 0) {
                desc->mbox_init_p = 0;
        }
 
        /* </hack --place="ready_async-pre-reply" type="verbatim"--> */
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _SP_JOIN:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _SP_LEAVE:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _SP_MULTICAST:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _SP_MULTIGROUP_MULTICAST:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _SP_POLL:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _SP_RECEIVE:
        reply_xtra_xret_receive(desc, c);
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->i.groups != NULL) {
                sys_free(c->i.groups);
        }
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _SP_GET_GID_OFFSET_MEMB_MESS:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _SP_GET_NUM_VS_OFFSET_MEMB_MESS:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _SP_GET_VS_SET_OFFSET_MEMB_MESS:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _SET_ACTIVE:
        reply_ok_num(desc, c->o.ret_int);
        break;
    default:
        edtk_debug("%s: bogus command, should never happen", __FUNCTION__);
        break;
    }    
    for (i = 0; i < c->refc_bincount; i++) {
        driver_free_binary(c->refc_bin[i]);
    }
    sys_free(c);
}

static void
invoke__sp_connect(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_connect(
                          c->i.spread_name, 
                          c->i.private_name, 
                          c->i.priority, 
                          c->i.group_membership, 
                          c->i.mbox_ptr, 
                          c->i.private_group
                        );
    if (c->o.ret_int == ACCEPT_SESSION) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_disconnect(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_disconnect(
                          c->i.mbox
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_join(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_join(
                          c->i.mbox, 
                          c->i.group
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_leave(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_leave(
                          c->i.mbox, 
                          c->i.group
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_multicast(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_multicast(
                          c->i.mbox, 
                          c->i.service_type, 
                          c->i.group, 
                          c->i.mess_type, 
                          c->i.__stash[0], 
                          c->i.mess
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_multigroup_multicast(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_multigroup_multicast(
                          c->i.mbox, 
                          c->i.service_type, 
                          c->i.groups, 
                          c->i.mess_type, 
                          c->i.__stash[0], 
                          c->i.mess
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_poll(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_poll(
                          c->i.mbox
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_receive(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_receive(
                          c->i.mbox, 
                         & c->o.service_type, 
                          c->i.sender, 
                          c->i.max_groups, 
                         & c->o.num_groups, 
                         (char (*)[MAX_GROUP_NAME])  c->i.groups, 
                         & c->o.mess_type, 
                         & c->o.endian_mismatch, 
                          c->i.max_mess_len, 
                          c->i.mess
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_get_gid_offset_memb_mess(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_get_gid_offset_memb_mess(
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_get_num_vs_offset_memb_mess(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_get_num_vs_offset_memb_mess(
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__sp_get_vs_set_offset_memb_mess(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = SP_get_vs_set_offset_memb_mess(
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__set_active(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_set_active(
                          c->i.drv_data, 
                          c->i.value
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}


static int
reply_ok(descriptor_t *desc)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 2);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_ok_num(descriptor_t *desc, unsigned long num)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_INT(msg, i, num);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, num = %lu", __FUNCTION__, i, num);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_binary(descriptor_t *desc, char *ptr, int beg_offset, int length)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_BINARY(msg, i, edtk_alloced_ptr2ErlDrvBinary(ptr),
                    beg_offset, length);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, ptr = 0x%lx, start = %d, end = %d",
    __FUNCTION__, i, ptr, beg_offset, length);
    res = driver_output_term(desc->port, msg, i);
    /* driver_output_term() incrs refc, and we're done, so decr refc */
    /*
    ** We _know_ that "ptr" points to memory allocated by
    ** edtk_driver_alloc_wrapper(), so edtk_alloced_ptr2ErlDrvBinary()
    ** is safe in this case.  If it weren't safe, then the binary
    ** must be returned by an xtra_return, which means we
    ** reply_ok_binary()) are never called!
    */
    driver_free_binary(edtk_alloced_ptr2ErlDrvBinary(ptr));
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_valmap(descriptor_t *desc, ErlDrvTermData valmap_atom,
                unsigned long valmap_index)
{
    ErlDrvTermData      msg[15];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_ATOM(msg, i, valmap_atom);
    i = LOAD_INT(msg, i, valmap_index);
    i = LOAD_TUPLE(msg, i, 2);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok_valmap: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok_valmap: res = %d", res);
    return res;
}

static int
reply_error(descriptor_t *desc, int errnum)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}

static int
reply_error_atom(descriptor_t *desc, ErlDrvTermData atom)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_ATOM(msg, i, atom);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d", __FUNCTION__, i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

#if     0       /* XXX These are unused right now */
static int
reply_tag_ok(descriptor_t *desc, unsigned short tag)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum)
{
    ErlDrvTermData      msg[24];
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_TUPLE(msg, i, 4);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}
#endif  /* 0 */


static int
reply_xtra_xret_connect(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[MAX_RETURN_TERMS];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    desc->num_tofree = 0;

    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* members will be 2 very shortly: Port & ok|error */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             if ((tmp = edtk_driver_alloc_wrapper(strlen(c->i.private_group))) == NULL) {
              return reply_error(desc, ENOMEM);
             }
             memcpy(tmp,  c->i.private_group, strlen(c->i.private_group));
             tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
             msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->i.private_group));
             /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
             desc->tofree[desc->num_tofree++] = tmpbin;
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, c->o.ret_int);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_xret_connect: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_xret_connect: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_xret_connect: driver_output_term() failed!  This should never happen!\r\n\r\n");
    }

    for (i = 0; i < desc->num_tofree; i++) {
        driver_free_binary(desc->tofree[i]);
    }
    return res;
}

static int
reply_xtra_xret_receive(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[MAX_RETURN_TERMS];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    desc->num_tofree = 0;

    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* members will be 2 very shortly: Port & ok|error */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, c->o.service_type);
             members++;
             if ((tmp = edtk_driver_alloc_wrapper(strlen(c->i.sender))) == NULL) {
              return reply_error(desc, ENOMEM);
             }
             memcpy(tmp,  c->i.sender, strlen(c->i.sender));
             tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
             msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->i.sender));
             /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
             desc->tofree[desc->num_tofree++] = tmpbin;
             members++;
             {
                 int members = 0;
                 
                 make_xret_group_list(desc, c, msg, &members, &msgcount);
                 msgcount = LOAD_LIST(msg, msgcount, members);
             }
             members++;
             msgcount = LOAD_INT(msg, msgcount, c->o.mess_type);
             members++;
             msgcount = LOAD_INT(msg, msgcount, c->o.endian_mismatch);
             members++;
             tmpbin = edtk_alloced_ptr2ErlDrvBinary(c->i.mess);
             msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, c->o.ret_int);
             /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
             desc->tofree[desc->num_tofree++] = tmpbin;
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, c->o.ret_int);
             members++;
             msgcount = LOAD_INT(msg, msgcount, c->o.num_groups);
             members++;
             msgcount = LOAD_INT(msg, msgcount, c->o.endian_mismatch);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_xret_receive: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_xret_receive: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_xret_receive: driver_output_term() failed!  This should never happen!\r\n\r\n");
    }

    for (i = 0; i < desc->num_tofree; i++) {
        driver_free_binary(desc->tofree[i]);
    }
    return res;
}



