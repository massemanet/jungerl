/*
** File    : posix_drv.c
** Summary : Simple POSIX system call driver
** 
** NOTICE: This file was generated by the tools of the Erlang Driver
**         toolkit.  Do not edit this file by hand unless you know
**         what you're doing!
** 
** Copyright (c) 2003, Scott Lystig Fritchie.  All rights reserved.
** See the file "../LICENSE" for license details.
*/

/*
** QQQ Before I forget yet again to write this down...
**
** ... the valmap ID assignment has a weakness that should be fixed
** sometime in the future.  The weakness is that reusing the array
** indexes could result in Erlang being able to access a later
** incarnation of a valmap table entry by simply remembering a
** previous valmap {valmap_blah, Integer} and resending it to the
** driver, hoping to get (un)lucky.  
**
** The solution would be to choose a valmap index from a larger, very
** unlikely to repeat set, and use a mapping data structure less naive
** than a dumb array.
**
** QQQ cannot pass references from driver -> Erlang!  Gah!
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <assert.h>
#ifdef   DRIVER_USING_PTHREADS
#include <pthread.h>
#else    /* DRIVER_USING_PTHREADS */
#define  pthread_self()         0
#endif   /* DRIVER_USING_PTHREADS */

/* TODO: Add additional system & local header file #includes */

#include <erl_driver.h>
#include <erl_driver_tk.h>

/* <verbatim place="top_cpp_stuff"> */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
/* BSD-specific? (for NGROUPS_MAX) #include <sys/syslimits.h> */

#ifndef NGROUPS_MAX
#define NGROUPS_MAX     64      /* Big, but we'll be safe */
#endif  /* !NGROUPS_MAX */

#include <posix_drv.h>
#include <my-posix.h>


/* </verbatim --place="top_cpp_stuff"--> */

/* Last, but not least.... */
#include <posix_drv.h>


static ErlDrvTermData am_ok;
static ErlDrvTermData am_error;
static ErlDrvTermData am_badarg;
static ErlDrvTermData am_enomem;
static ErlDrvTermData am_unknown;
static ErlDrvTermData am_stat;
static ErlDrvTermData am_passwd;
static ErlDrvTermData am_group;

static int default_async_calls = 0;

/* This variable may be set only by pipe-main! */
int pipe_driver_p = 0;

/*
** TODO: Define any other Erlang terms this driver may return.
*/

/* Function prototypes */

ErlDrvEntry *driver_init(void *);       /* Do not change name! */
static int _init(void);
static ErlDrvData _start(ErlDrvPort port, char *command);
static void _stop(ErlDrvData drv_data);
static void _output(ErlDrvData drv_data, char *buf, int len);
static int _control(ErlDrvData drv_data, unsigned int command, char *buf, int len, char **rbuf, int rlen);
static void _outputv(ErlDrvData drv_data, ErlIOVec *ev);
static void _ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data);

void *sys_alloc(size_t);
void *sys_realloc(void *, size_t);
void sys_free(void *);

static void invoke__getgid(void *data);
static void invoke__getegid(void *data);
static void invoke__getgrnam(void *data);
static void invoke__getgrgid(void *data);
static void invoke__getgroups(void *data);
static void invoke__getpwnam(void *data);
static void invoke__getpwuid(void *data);
static void invoke__getuid(void *data);
static void invoke__geteuid(void *data);
static void invoke__getlogin(void *data);
static void invoke__getpgrp(void *data);
static void invoke__getppid(void *data);
static void invoke__getsid(void *data);
static void invoke__kill(void *data);
static void invoke__lstat(void *data);
static void invoke__mkfifo(void *data);
static void invoke__mknod(void *data);
static void invoke__umask(void *data);

static int reply_xtra_stat(descriptor_t *, callstate_t *);
static int reply_xtra_passwd(descriptor_t *, callstate_t *);
static int reply_xtra_group(descriptor_t *, callstate_t *);
static int reply_xtra_getgroups(descriptor_t *, callstate_t *);


static int reply_ok(descriptor_t *desc);
static int reply_ok_num(descriptor_t *desc, unsigned long num);
static int reply_ok_binary(descriptor_t *desc, char *p, int, int);
static int reply_ok_valmap(descriptor_t *, ErlDrvTermData, unsigned long);
static int reply_error(descriptor_t *desc, int errnum);
static int reply_error_atom(descriptor_t *, ErlDrvTermData);
#if     0
static int reply_tag_ok(descriptor_t *desc, unsigned short tag);
static int reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum);
#endif  /* 0 */

static ErlDrvEntry _driver_entry = {
    _init,                      /* init */
    _start,                     /* start */
    _stop,                      /* stop */
    _output,                    /* output */
    NULL,                       /* ready_input */
    NULL,                       /* ready_output */
    "posix_drv",                /* driver_name */
    NULL,                       /* finish */
    NULL,                       /* handle */
    _control,                   /* control */
    NULL,                       /* timeout */
    _outputv,                   /* outputv */
    _ready_async,               /* ready_async */
    NULL,                       /* flush */
    NULL                        /* call */
};

/*
** All dynamically-loadable driver libraries must contain a driver_init().
*/

ErlDrvEntry *
driver_init(void *handle)
{
    edtk_debug_flag = 0;
    _driver_entry.handle = handle;
    return &_driver_entry;
}

static int
_init(void)
{
    am_ok = driver_mk_atom("ok");
    am_error = driver_mk_atom("error");
    am_badarg = driver_mk_atom("badarg");
    am_enomem = driver_mk_atom("enomem");
    am_unknown = driver_mk_atom("unknown");
    am_stat = driver_mk_atom("stat");
    am_passwd = driver_mk_atom("passwd");
    am_group = driver_mk_atom("group");

    /* TODO: Take care of other first-time initialization tasks */

    return 0;
}

static ErlDrvData
_start(ErlDrvPort port, char *args)
{
    descriptor_t        *desc;
    int                 i = 0;

    i = i;
    edtk_debug("%s: starting, port = %ld, args = 0x%lx, %s", __FUNCTION__,
               port, (unsigned long) args, args);

    if ((desc = (descriptor_t *) sys_alloc(sizeof(descriptor_t))) == NULL) {
        return ERL_DRV_ERROR_GENERAL;
    }
    memset(desc, 0, sizeof(descriptor_t));
    desc->port = port;
    desc->nextxid = 1;
    /* TODO: Finish initializing descriptor members */

    /* TODO: Take care of other port initialization tasks */

    return (ErlDrvData) desc;
}

static void
_stop(ErlDrvData drv_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    int                 i = 0;
    ErlDrvPort          port;
    int                 still_in_use = 0;

    i = i;
    if (desc == NULL) {
        edtk_debug("%s: drv_data == NULL", __FUNCTION__);
        return;
    }
    edtk_debug("%s: port = %ld", __FUNCTION__, desc->port);


    if (! still_in_use) {
        port = desc->port;
        sys_free(desc);    
        edtk_debug("%s: port = %ld finished", __FUNCTION__, port);
    } else {
        /*
        ** QQQ Oi, this is a sticky problem.  This port is being shut
        ** down, but we've still got some valmaps in use.  We have no
        ** way to tell the VM that we cannot be shut down safely right
        ** now, so what in the heck do we do?  It seems to me that we
        ** have two choices:
        **   1. Block the entire VM until all valmaps are idle, then
        **      clean them up and then return.
        **   2. Create a new thread that will take care of monitoring
        **      the valmaps & doing their final cleanup.  This stop
        **      function, executing in the main thread, can return
        **      to the VM right away.
        ** For the sake of simplicity, I'm going to implement #1
        ** for now.  This will get more complicated once EDTK supports
        ** private worker threads, so we won't bother getting fancy
        ** for now.
        */
        edtk_debug("%s: port = %ld has %d valmaps still in use!", __FUNCTION__, desc->port, still_in_use);

        /*
        ** QQQ Perhaps an alternative would be to create another
        ** thread to (slowly) spin-wait on still-in-use valmap, and
        ** when it's idle, have that thread free "desc" then exit?
        */
        sleep(1);  /* QQQ Ouch, this is brute force, but hey, it's simple */
        _stop(drv_data);                /* Hope we don't run out of stack */
    }
}

static void
_output(ErlDrvData drv_data, char *buf, int len)
{
    /*
    ** Nobody should be calling this function because we've
    ** defined the "outputv" driver method, which BEAM will always
    ** used if it's available.  I just put a debug statement in
    ** here so that I might actually notice if the impossible ever
    ** happens....
    */
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
}

static int
_control(ErlDrvData drv_data, unsigned int command,
                  char *buf, int len, char **rbuf, int rlen)
{
    char        *ret = *rbuf;
    int         retlen;

    /*
    ** Nobody should be calling this function either.
    */
    ret[0] = 1;
    retlen = 1;
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
    return retlen;
}

static void
_outputv(ErlDrvData drv_data, ErlIOVec *ev)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    unsigned char       cmd;
    int                 p = 0, q = 1;
    callstate_t         *c = NULL;
    int                 do_async_call = default_async_calls;
    unsigned long       binlen;
    int                 index;
    void                *tmp = NULL;

    binlen = binlen;
    index = index;
    tmp = tmp;
    if (desc == NULL || ev == NULL || ev->size < 1) {
        edtk_debug("%s: bad arg(s)", __FUNCTION__);
        return;
    }
    if (! EV_GET_CHAR(ev, &cmd, &p, &q)) {
        edtk_debug("%s: empty command", __FUNCTION__);
        reply_error(desc, EINVAL);
    }
    if ((c = sys_alloc(sizeof(callstate_t))) == NULL) {
        reply_error(desc, ENOMEM);
        return;
    }
    c->cmd = cmd;
    c->key = NULL;
    c->free = sys_free;
    c->xid = 0;         /* QQQ unused right now */
    c->o.__expect = 1;  /* Default is that expectation is always met */

    edtk_debug("%s: my threadid = %lx, cmd = %d", __FUNCTION__, pthread_self(), cmd);
    switch (cmd) {
    case _DEBUG:
        EV_GET_UINT32(ev, &edtk_debug_flag, &p, &q);
        reply_ok_num(desc, edtk_debug_flag);    /* Immediate reply */
        sys_free(c);
        c = NULL;
        break;
    case _GETGID:
        c->invoke = invoke__getgid;
        break;
    case _GETEGID:
        c->invoke = invoke__getegid;
        break;
    case _GETGRNAM:
        c->invoke = invoke__getgrnam;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.name = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GETGRGID:
        c->invoke = invoke__getgrgid;
        EV_GET_UINT32(ev, &c->i.gid, &p, &q);
        break;
    case _GETGROUPS:
        c->invoke = invoke__getgroups;
        break;
    case _GETPWNAM:
        c->invoke = invoke__getpwnam;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.login = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GETPWUID:
        c->invoke = invoke__getpwuid;
        EV_GET_UINT32(ev, &c->i.uid, &p, &q);
        break;
    case _GETUID:
        c->invoke = invoke__getuid;
        break;
    case _GETEUID:
        c->invoke = invoke__geteuid;
        break;
    case _GETLOGIN:
        c->invoke = invoke__getlogin;
        break;
    case _GETPGRP:
        c->invoke = invoke__getpgrp;
        break;
    case _GETPPID:
        c->invoke = invoke__getppid;
        break;
    case _GETSID:
        c->invoke = invoke__getsid;
        /* <hack place="post-deserialize" type="verbatim"> */

        c->i.pid = 0;
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _KILL:
        c->invoke = invoke__kill;
        EV_GET_UINT32(ev, &c->i.pid, &p, &q);
        EV_GET_UINT32(ev, &c->i.sig, &p, &q);
        break;
    case _LSTAT:
        c->invoke = invoke__lstat;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.path = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _MKFIFO:
        c->invoke = invoke__mkfifo;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.path = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.mode, &p, &q);
        break;
    case _MKNOD:
        c->invoke = invoke__mknod;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.path = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.mode, &p, &q);
        EV_GET_UINT32(ev, &c->i.dev, &p, &q);
        break;
    case _UMASK:
        c->invoke = invoke__umask;
        EV_GET_UINT32(ev, &c->i.numask, &p, &q);
        break;
     default:
        edtk_debug("%s: invalid command %d", __FUNCTION__, cmd);
        goto error;
        break;  
    }
    if (c != NULL) {
        if (do_async_call) {
            driver_async(desc->port, c->key, c->invoke, c, c->free);
        } else {
            /*
            ** Execute the bottom half right away, then send the result.
            */
            (*(c->invoke))((void *) c);
            _ready_async((ErlDrvData) desc, (ErlDrvThreadData) c);
            /* 
            ** c is already freed for us by _ready_async()
            */
        }
    }
    return;

  error:
    if (c != NULL) {
        sys_free(c);
    }
    reply_error_atom(desc, am_badarg);
}

static void
_ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    callstate_t *c = (callstate_t *) thread_data;
    int                 bytes, offset, i;
    char                *p = NULL;
    unsigned long       index = 0;

    p = p;
    bytes = bytes;
    offset = offset;
    i = i;
    index = index;
    edtk_debug("%s: cmd = %d", __FUNCTION__, c->cmd);
    if (c == NULL) {
        edtk_debug("%s: c == NULL", __FUNCTION__);
        return;
    }
    switch (c->cmd) {
    case _GETGID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_gid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETEGID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_gid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETGRNAM:
        reply_xtra_group(desc, c);
        break;
    case _GETGRGID:
        reply_xtra_group(desc, c);
        break;
    case _GETGROUPS:
        reply_xtra_getgroups(desc, c);
        break;
    case _GETPWNAM:
        reply_xtra_passwd(desc, c);
        break;
    case _GETPWUID:
        reply_xtra_passwd(desc, c);
        break;
    case _GETUID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_uid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETEUID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_uid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETLOGIN:
        bytes = strlen(c->o.ret_char_p);
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_char_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        break;
    case _GETPGRP:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_pid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETPPID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_pid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GETSID:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_pid_t);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _KILL:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _LSTAT:
        reply_xtra_stat(desc, c);
        break;
    case _MKFIFO:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _MKNOD:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _UMASK:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    default:
        edtk_debug("%s: bogus command, should never happen", __FUNCTION__);
        break;
    }    
    sys_free(c);
}

static void
invoke__getgid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gid_t = getgid(
                        );
    if (c->o.ret_gid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getegid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gid_t = getegid(
                        );
    if (c->o.ret_gid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getgrnam(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_grptr = getgrnam(
                          c->i.name
                        );
    if (c->o.ret_grptr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getgrgid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_grptr = getgrgid(
                          c->i.gid
                        );
    if (c->o.ret_grptr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getgroups(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_getgroups(
                          c->o.gidset
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getpwnam(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_pwptr = getpwnam(
                          c->i.login
                        );
    if (c->o.ret_pwptr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getpwuid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_pwptr = getpwuid(
                          c->i.uid
                        );
    if (c->o.ret_pwptr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getuid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_uid_t = getuid(
                        );
    if (c->o.ret_uid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__geteuid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_uid_t = geteuid(
                        );
    if (c->o.ret_uid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getlogin(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_char_p = getlogin(
                        );
    if (c->o.ret_char_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getpgrp(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_pid_t = getpgrp(
                        );
    if (c->o.ret_pid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getppid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_pid_t = getppid(
                        );
    if (c->o.ret_pid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getsid(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_pid_t = getsid(
                          c->i.pid
                        );
    if (c->o.ret_pid_t >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__kill(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = kill(
                          c->i.pid, 
                          c->i.sig
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__lstat(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = lstat(
                          c->i.path, 
                         & c->o.sb
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__mkfifo(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = mkfifo(
                          c->i.path, 
                          c->i.mode
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__mknod(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = mknod(
                          c->i.path, 
                          c->i.mode, 
                          c->i.dev
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__umask(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = umask(
                          c->i.numask
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}


static int
reply_ok(descriptor_t *desc)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 2);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_ok_num(descriptor_t *desc, unsigned long num)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_INT(msg, i, num);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, num = %lu", __FUNCTION__, i, num);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_binary(descriptor_t *desc, char *ptr, int beg_offset, int length)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_BINARY(msg, i, edtk_alloced_ptr2ErlDrvBinary(ptr),
                    beg_offset, length);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, ptr = 0x%lx, start = %d, end = %d",
    __FUNCTION__, i, ptr, beg_offset, length);
    res = driver_output_term(desc->port, msg, i);
    /* driver_output_term() incrs refc, and we're done, so decr refc */
    /*
    ** We _know_ that "ptr" points to memory allocated by
    ** edtk_driver_alloc_wrapper(), so edtk_alloced_ptr2ErlDrvBinary()
    ** is safe in this case.  If it weren't safe, then the binary
    ** must be returned by an xtra_return, which means we
    ** reply_ok_binary()) are never called!
    */
    driver_free_binary(edtk_alloced_ptr2ErlDrvBinary(ptr));
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_valmap(descriptor_t *desc, ErlDrvTermData valmap_atom,
                unsigned long valmap_index)
{
    ErlDrvTermData      msg[15];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_ATOM(msg, i, valmap_atom);
    i = LOAD_INT(msg, i, valmap_index);
    i = LOAD_TUPLE(msg, i, 2);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok_valmap: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok_valmap: res = %d", res);
    return res;
}

static int
reply_error(descriptor_t *desc, int errnum)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}

static int
reply_error_atom(descriptor_t *desc, ErlDrvTermData atom)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_ATOM(msg, i, atom);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d", __FUNCTION__, i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

#if     0       /* QQQ These are unused right now */
static int
reply_tag_ok(descriptor_t *desc, unsigned short tag)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_TUPLE(msg, i, 4);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}
#endif  /* 0 */


static int
reply_xtra_stat(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[64];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    ErlDrvBinary        *tofree[64];
    int                 num_tofree = 0;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* Rather, members will be 2 very shortly */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             {
                 int members = 0;

                 msgcount = LOAD_ATOM(msg, msgcount, am_stat);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_dev);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_ino);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_mode);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_nlink);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_uid);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_gid);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_rdev);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_atime);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_mtime);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_ctime);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_size);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_blocks);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.sb.st_blksize);
                 members++;
                 msgcount = LOAD_TUPLE(msg, msgcount, members); /* XXX */
             }
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, errno);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_stat: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_stat: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_stat: driver_output_term() failed!          This should never happen!\r\n\r\n");
    }

    for (i = 0; i < num_tofree; i++) {
        driver_free_binary(tofree[i]);
    }
    return res;
}

static int
reply_xtra_passwd(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[64];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    ErlDrvBinary        *tofree[64];
    int                 num_tofree = 0;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* Rather, members will be 2 very shortly */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             {
                 int members = 0;

                 msgcount = LOAD_ATOM(msg, msgcount, am_passwd);
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_pwptr->pw_name))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_pwptr->pw_name, strlen(c->o.ret_pwptr->pw_name));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_pwptr->pw_name));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_pwptr->pw_passwd))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_pwptr->pw_passwd, strlen(c->o.ret_pwptr->pw_passwd));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_pwptr->pw_passwd));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.ret_pwptr->pw_uid);
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.ret_pwptr->pw_gid);
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_pwptr->pw_gecos))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_pwptr->pw_gecos, strlen(c->o.ret_pwptr->pw_gecos));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_pwptr->pw_gecos));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_pwptr->pw_dir))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_pwptr->pw_dir, strlen(c->o.ret_pwptr->pw_dir));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_pwptr->pw_dir));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_pwptr->pw_shell))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_pwptr->pw_shell, strlen(c->o.ret_pwptr->pw_shell));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_pwptr->pw_shell));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 msgcount = LOAD_TUPLE(msg, msgcount, members); /* XXX */
             }
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, c->o.__expect_errval);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_passwd: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_passwd: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_passwd: driver_output_term() failed!        This should never happen!\r\n\r\n");
    }

    for (i = 0; i < num_tofree; i++) {
        driver_free_binary(tofree[i]);
    }
    return res;
}

static int
reply_xtra_group(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[64];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    ErlDrvBinary        *tofree[64];
    int                 num_tofree = 0;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* Rather, members will be 2 very shortly */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             {
                 int members = 0;

                 msgcount = LOAD_ATOM(msg, msgcount, am_group);
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_grptr->gr_name))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_grptr->gr_name, strlen(c->o.ret_grptr->gr_name));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_grptr->gr_name));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 if ((tmp = edtk_driver_alloc_wrapper(strlen(c->o.ret_grptr->gr_passwd))) == NULL) {
                  return reply_error(desc, ENOMEM);
                 }
                 memcpy(tmp,  c->o.ret_grptr->gr_passwd, strlen(c->o.ret_grptr->gr_passwd));
                 tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
                 msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, strlen(c->o.ret_grptr->gr_passwd));
                 /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
                 tofree[num_tofree++] = tmpbin;
                 members++;
                 msgcount = LOAD_INT(msg, msgcount, c->o.ret_grptr->gr_gid);
                 members++;
                 {
                     int members = 0;
                     
                     make_groups_list(desc, c, msg, &members, &msgcount);
                     msgcount = LOAD_LIST(msg, msgcount, members); /* XXX */
                 }
                 members++;
                 msgcount = LOAD_TUPLE(msg, msgcount, members); /* XXX */
             }
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, c->o.__expect_errval);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_group: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_group: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_group: driver_output_term() failed!         This should never happen!\r\n\r\n");
    }

    for (i = 0; i < num_tofree; i++) {
        driver_free_binary(tofree[i]);
    }
    return res;
}

static int
reply_xtra_getgroups(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[64];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    ErlDrvBinary        *tofree[64];
    int                 num_tofree = 0;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* Rather, members will be 2 very shortly */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             {
                 int members = 0;

                 msgcount = LOAD_INT(msg, msgcount, c->o.ret_int);
                 members++;
                 {
                     int members = 0;
                     
                     make_getgroups_list(desc, c, msg, &members, &msgcount);
                     msgcount = LOAD_LIST(msg, msgcount, members); /* XXX */
                 }
                 members++;
                 msgcount = LOAD_TUPLE(msg, msgcount, members); /* XXX */
             }
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, errno);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_getgroups: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_getgroups: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_getgroups: driver_output_term() failed!     This should never happen!\r\n\r\n");
    }

    for (i = 0; i < num_tofree; i++) {
        driver_free_binary(tofree[i]);
    }
    return res;
}



