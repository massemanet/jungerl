<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module erl_syntax</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body bgcolor="white">
<h1>Module erl_syntax</h1>
<ul><li>
<a href="#index">Function index</a></li><li>
<a href="#exported">Exported functions</a></li><li>
<a href="#types">Data Types</a></li><li>
<a href="#internal">Documented Internal Functions</a></li></ul>

<h2>Description</h2>
Abstract Erlang syntax trees.
 
  <p> This module defines an abstract data type for representing Erlang
  source code as syntax trees, in a way that is backwards compatible
  with the data structures created by the Erlang standard library
  parser module <code>erl_parse</code> (often referred to as "parse
  trees", which is a bit of a misnomer). This means that all
  <code>erl_parse</code> trees are valid abstract syntax trees, but the
  reverse is not true: abstract syntax trees can in general not be used
  as input to functions expecting an <code>erl_parse</code> tree.
  However, as long as an abstract syntax tree represents a correct
  Erlang program, the function <code>revert/1</code> should be able to
  transform it to the corresponding <code>erl_parse</code>
  representation.</p>
 
  <p>A recommended starting point for the first-time user is the
  documentation of the function <a href="#type-1"><code>type/1</code></a>.</p>
 
  <h3><b>NOTES:</b></h3>
 
  <p>This module deals with the composition and decomposition of
  <em>syntactic</em> entities (as opposed to semantic ones); its
  purpose is to hide all direct references to the data structures used
  to represent these entities. With few exceptions, the functions in
  this module perform no semantic interpretation of their inputs, and
  in general, the user is assumed to pass type-correct arguments - if
  this is not done, the effects are not defined.</p>
 
  <p>With the exception of the <code>erl_parse</code> data structures,
  the internal representations of abstract syntax trees are subject to
  change without notice, and should not be documented outside this
  module. Furthermore, we do not give any guarantees on how an abstract
  syntax tree may or may not be represented, <em>with the following
  exceptions</em>: no syntax tree is represented by a single atom, such
  as <code>none</code>, by a list constructor <code>[X | Y]</code>, or
  by the empty list <code>[]</code>. This can be relied on when writing
  functions that operate on syntax trees.</p>
 

<h2><a name="index">Function Index</a></h2>

<table width="100%" border="1"><tr><th colspan="2" align="left">Exported Functions</th></tr>
<tr><td><a href="#abstract-1">abstract/1</a></td><td>Returns the syntax tree corresponding to an Erlang term.</td></tr>
<tr><td><a href="#add_ann-2">add_ann/2</a></td><td>Appends the term <code>Annotation</code> to the list of user
  annotations of <code>Node</code>.</td></tr>
<tr><td><a href="#add_postcomments-2">add_postcomments/2</a></td><td>Appends <code>Comments</code> to the post-comments of
  <code>Node</code>.</td></tr>
<tr><td><a href="#add_precomments-2">add_precomments/2</a></td><td>Appends <code>Comments</code> to the pre-comments of
  <code>Node</code>.</td></tr>
<tr><td><a href="#application-2">application/2</a></td><td>Creates an abstract function application expression.</td></tr>
<tr><td><a href="#application-3">application/3</a></td><td>Creates an abstract function application expression.</td></tr>
<tr><td><a href="#application_arguments-1">application_arguments/1</a></td><td>Returns the list of argument subtrees of an
  <code>application</code> node.</td></tr>
<tr><td><a href="#application_operator-1">application_operator/1</a></td><td>Returns the operator subtree of an <code>application</code>
  node.</td></tr>
<tr><td><a href="#arity_qualifier-2">arity_qualifier/2</a></td><td>Creates an abstract arity qualifier.</td></tr>
<tr><td><a href="#arity_qualifier_argument-1">arity_qualifier_argument/1</a></td><td>Returns the argument (the arity) subtree of an
  <code>arity_qualifier</code> node.</td></tr>
<tr><td><a href="#arity_qualifier_body-1">arity_qualifier_body/1</a></td><td>Returns the body subtree of an <code>arity_qualifier</code>
  node.</td></tr>
<tr><td><a href="#atom-1">atom/1</a></td><td>Creates an abstract atom literal.</td></tr>
<tr><td><a href="#atom_literal-1">atom_literal/1</a></td><td>Returns the literal string represented by an <code>atom</code>
  node.</td></tr>
<tr><td><a href="#atom_name-1">atom_name/1</a></td><td>Returns the printname of an <code>atom</code> node.</td></tr>
<tr><td><a href="#atom_value-1">atom_value/1</a></td><td>Returns the value represented by an <code>atom</code> node.</td></tr>
<tr><td><a href="#attribute-1">attribute/1</a></td><td><a href="#attribute-2">See <code>attribute/2</code>.</a></td></tr>
<tr><td><a href="#attribute-2">attribute/2</a></td><td>Creates an abstract program attribute.</td></tr>
<tr><td><a href="#attribute_arguments-1">attribute_arguments/1</a></td><td>Returns the list of argument subtrees of an
  <code>attribute</code> node, if any.</td></tr>
<tr><td><a href="#attribute_name-1">attribute_name/1</a></td><td>Returns the name subtree of an <code>attribute</code> node.</td></tr>
<tr><td><a href="#binary-1">binary/1</a></td><td>Creates an abstract binary-object template.</td></tr>
<tr><td><a href="#binary_field-1">binary_field/1</a></td><td><a href="#binary_field-2">See <code>binary_field/2</code>.</a></td></tr>
<tr><td><a href="#binary_field-2">binary_field/2</a></td><td>Creates an abstract binary template field.</td></tr>
<tr><td><a href="#binary_field-3">binary_field/3</a></td><td>Creates an abstract binary template field.</td></tr>
<tr><td><a href="#binary_field_body-1">binary_field_body/1</a></td><td>Returns the body subtree of a <code>binary_field</code>.</td></tr>
<tr><td><a href="#binary_field_size-1">binary_field_size/1</a></td><td>Returns the size specifier subtree of a
  <code>binary_field</code> node, if any.</td></tr>
<tr><td><a href="#binary_field_types-1">binary_field_types/1</a></td><td>Returns the list of type-specifier subtrees of a
  <code>binary_field</code> node.</td></tr>
<tr><td><a href="#binary_fields-1">binary_fields/1</a></td><td>Returns the list of field subtrees of a <code>binary</code>
  node.</td></tr>
<tr><td><a href="#block_expr-1">block_expr/1</a></td><td>Creates an abstract block expression.</td></tr>
<tr><td><a href="#block_expr_body-1">block_expr_body/1</a></td><td>Returns the list of body subtrees of a <code>block_expr</code>
  node.</td></tr>
<tr><td><a href="#case_expr-2">case_expr/2</a></td><td>Creates an abstract case-expression.</td></tr>
<tr><td><a href="#case_expr_argument-1">case_expr_argument/1</a></td><td>Returns the argument subtree of a <code>case_expr</code> node.</td></tr>
<tr><td><a href="#case_expr_clauses-1">case_expr_clauses/1</a></td><td>Returns the list of clause subtrees of a <code>case_expr</code>
  node.</td></tr>
<tr><td><a href="#catch_expr-1">catch_expr/1</a></td><td>Creates an abstract catch-expression.</td></tr>
<tr><td><a href="#catch_expr_body-1">catch_expr_body/1</a></td><td>Returns the body subtree of a <code>catch_expr</code> node.</td></tr>
<tr><td><a href="#char-1">char/1</a></td><td>Creates an abstract character literal.</td></tr>
<tr><td><a href="#char_literal-1">char_literal/1</a></td><td>Returns the literal string represented by a <code>char</code>
  node.</td></tr>
<tr><td><a href="#char_value-1">char_value/1</a></td><td>Returns the value represented by a <code>char</code> node.</td></tr>
<tr><td><a href="#clause-2">clause/2</a></td><td><a href="#clause-3">See <code>clause/3</code>.</a></td></tr>
<tr><td><a href="#clause-3">clause/3</a></td><td>Creates an abstract clause.</td></tr>
<tr><td><a href="#clause_body-1">clause_body/1</a></td><td>Return the list of body subtrees of a <code>clause</code>
  node.</td></tr>
<tr><td><a href="#clause_guard-1">clause_guard/1</a></td><td>Returns the guard subtree of a <code>clause</code> node, if
  any.</td></tr>
<tr><td><a href="#clause_patterns-1">clause_patterns/1</a></td><td>Returns the list of pattern subtrees of a <code>clause</code>
  node.</td></tr>
<tr><td><a href="#comment-1">comment/1</a></td><td><a href="#comment-2">See <code>comment/2</code>.</a></td></tr>
<tr><td><a href="#comment-2">comment/2</a></td><td>Creates an abstract comment with the given padding and text.</td></tr>
<tr><td><a href="#comment_padding-1">comment_padding/1</a></td><td>Returns the amount of padding before the comment, or
  <code>none</code>.</td></tr>
<tr><td><a href="#comment_text-1">comment_text/1</a></td><td>Returns the lines of text of the abstract comment.</td></tr>
<tr><td><a href="#compact_list-1">compact_list/1</a></td><td>Yields the most compact form for an abstract list skeleton.</td></tr>
<tr><td><a href="#concrete-1">concrete/1</a></td><td>Returns the Erlang term represented by a syntax tree.</td></tr>
<tr><td><a href="#conjunction-1">conjunction/1</a></td><td>Creates an abstract conjunction.</td></tr>
<tr><td><a href="#conjunction_body-1">conjunction_body/1</a></td><td>Returns the list of body subtrees of a
  <code>conjunction</code> node.</td></tr>
<tr><td><a href="#cons-2">cons/2</a></td><td>"Optimising" list skeleton cons operation.</td></tr>
<tr><td><a href="#copy_ann-2">copy_ann/2</a></td><td>Copies the list of user annotations from <code>Source</code> to
  <code>Target</code>.</td></tr>
<tr><td><a href="#copy_attrs-2">copy_attrs/2</a></td><td>Copies the attributes from <code>Source</code> to
  <code>Target</code>.</td></tr>
<tr><td><a href="#copy_comments-2">copy_comments/2</a></td><td>Copies the pre- and postcomments from <code>Source</code> to
  <code>Target</code>.</td></tr>
<tr><td><a href="#copy_pos-2">copy_pos/2</a></td><td>Copies the position information from <code>Source</code> to
  <code>Target</code>.</td></tr>
<tr><td><a href="#data-1">data/1</a></td><td><em>For special purposes only</em>.</td></tr>
<tr><td><a href="#disjunction-1">disjunction/1</a></td><td>Creates an abstract disjunction.</td></tr>
<tr><td><a href="#disjunction_body-1">disjunction_body/1</a></td><td>Returns the list of body subtrees of a
  <code>disjunction</code> node.</td></tr>
<tr><td><a href="#eof_marker-0">eof_marker/0</a></td><td>Creates an abstract end-of-file marker.</td></tr>
<tr><td><a href="#error_marker-1">error_marker/1</a></td><td>Creates an abstract error marker.</td></tr>
<tr><td><a href="#error_marker_info-1">error_marker_info/1</a></td><td>Returns the ErrorInfo structure of an <code>error_marker</code>
  node.</td></tr>
<tr><td><a href="#flatten_form_list-1">flatten_form_list/1</a></td><td>Flattens sublists of a <code>form_list</code> node.</td></tr>
<tr><td><a href="#float-1">float/1</a></td><td>Creates an abstract floating-point literal.</td></tr>
<tr><td><a href="#float_literal-1">float_literal/1</a></td><td>Returns the numeral string represented by a <code>float</code>
  node.</td></tr>
<tr><td><a href="#float_value-1">float_value/1</a></td><td>Returns the value represented by a <code>float</code> node.</td></tr>
<tr><td><a href="#form_list-1">form_list/1</a></td><td>Creates an abstract sequence of "source code forms".</td></tr>
<tr><td><a href="#form_list_elements-1">form_list_elements/1</a></td><td>Returns the list of subnodes of a <code>form_list</code> node.</td></tr>
<tr><td><a href="#fun_expr-1">fun_expr/1</a></td><td>Creates an abstract fun-expression.</td></tr>
<tr><td><a href="#fun_expr_arity-1">fun_expr_arity/1</a></td><td>Returns the arity of a <code>fun_expr</code> node.</td></tr>
<tr><td><a href="#fun_expr_clauses-1">fun_expr_clauses/1</a></td><td>Returns the list of clause subtrees of a <code>fun_expr</code>
  node.</td></tr>
<tr><td><a href="#function-2">function/2</a></td><td>Creates an abstract function definition.</td></tr>
<tr><td><a href="#function_arity-1">function_arity/1</a></td><td>Returns the arity of a <code>function</code> node.</td></tr>
<tr><td><a href="#function_clauses-1">function_clauses/1</a></td><td>Returns the list of clause subtrees of a <code>function</code>
  node.</td></tr>
<tr><td><a href="#function_name-1">function_name/1</a></td><td>Returns the name subtree of a <code>function</code> node.</td></tr>
<tr><td><a href="#generator-2">generator/2</a></td><td>Creates an abstract generator.</td></tr>
<tr><td><a href="#generator_body-1">generator_body/1</a></td><td>Returns the body subtree of a <code>generator</code> node.</td></tr>
<tr><td><a href="#generator_pattern-1">generator_pattern/1</a></td><td>Returns the pattern subtree of a <code>generator</code> node.</td></tr>
<tr><td><a href="#get_ann-1">get_ann/1</a></td><td>Returns the list of user annotations associated with a syntax
  tree node.</td></tr>
<tr><td><a href="#get_attrs-1">get_attrs/1</a></td><td>Returns a representation of the attributes associated with a
  syntax tree node.</td></tr>
<tr><td><a href="#get_pos-1">get_pos/1</a></td><td>Returns the position information associated with
  <code>Node</code>.</td></tr>
<tr><td><a href="#get_postcomments-1">get_postcomments/1</a></td><td>Returns the associated post-comments of a node.</td></tr>
<tr><td><a href="#get_precomments-1">get_precomments/1</a></td><td>Returns the associated pre-comments of a node.</td></tr>
<tr><td><a href="#has_comments-1">has_comments/1</a></td><td>Yields <code>false</code> if the node has no associated
  comments, and <code>true</code> otherwise.</td></tr>
<tr><td><a href="#if_expr-1">if_expr/1</a></td><td>Creates an abstract if-expression.</td></tr>
<tr><td><a href="#if_expr_clauses-1">if_expr_clauses/1</a></td><td>Returns the list of clause subtrees of an <code>if_expr</code>
  node.</td></tr>
<tr><td><a href="#implicit_fun-1">implicit_fun/1</a></td><td>Creates an abstract "implicit fun" expression.</td></tr>
<tr><td><a href="#implicit_fun-2">implicit_fun/2</a></td><td>Creates an abstract "implicit fun" expression.</td></tr>
<tr><td><a href="#implicit_fun_name-1">implicit_fun_name/1</a></td><td>Returns the name subtree of an <code>implicit_fun</code> node.</td></tr>
<tr><td><a href="#infix_expr-3">infix_expr/3</a></td><td>Creates an abstract infix operator expression.</td></tr>
<tr><td><a href="#infix_expr_left-1">infix_expr_left/1</a></td><td>Returns the left argument subtree of an
  <code>infix_expr</code> node.</td></tr>
<tr><td><a href="#infix_expr_operator-1">infix_expr_operator/1</a></td><td>Returns the operator subtree of an <code>infix_expr</code>
  node.</td></tr>
<tr><td><a href="#infix_expr_right-1">infix_expr_right/1</a></td><td>Returns the right argument subtree of an
  <code>infix_expr</code> node.</td></tr>
<tr><td><a href="#integer-1">integer/1</a></td><td>Creates an abstract integer literal.</td></tr>
<tr><td><a href="#integer_literal-1">integer_literal/1</a></td><td>Returns the numeral string represented by an
  <code>integer</code> node.</td></tr>
<tr><td><a href="#integer_value-1">integer_value/1</a></td><td>Returns the value represented by an <code>integer</code> node.</td></tr>
<tr><td><a href="#is_atom-2">is_atom/2</a></td><td>Returns <code>true</code> if <code>Node</code> has type
  <code>atom</code> and represents <code>Value</code>, otherwise
  <code>false</code>.</td></tr>
<tr><td><a href="#is_char-2">is_char/2</a></td><td>Returns <code>true</code> if <code>Node</code> has type
  <code>char</code> and represents <code>Value</code>, otherwise
  <code>false</code>.</td></tr>
<tr><td><a href="#is_form-1">is_form/1</a></td><td>Returns <code>true</code> if <code>Node</code> is a syntax tree
  representing a so-called "source code form", otherwise
  <code>false</code>.</td></tr>
<tr><td><a href="#is_integer-2">is_integer/2</a></td><td>Returns <code>true</code> if <code>Node</code> has type
  <code>integer</code> and represents <code>Value</code>, otherwise
  <code>false</code>.</td></tr>
<tr><td><a href="#is_leaf-1">is_leaf/1</a></td><td>Returns <code>true</code> if <code>Node</code> is a leaf node,
  otherwise <code>false</code>.</td></tr>
<tr><td><a href="#is_list_skeleton-1">is_list_skeleton/1</a></td><td>Returns <code>true</code> if <code>Node</code> has type
  <code>list</code> or <code>nil</code>, otherwise <code>false</code>.</td></tr>
<tr><td><a href="#is_literal-1">is_literal/1</a></td><td>Returns <code>true</code> if <code>Node</code> represents a
  literal term, otherwise <code>false</code>.</td></tr>
<tr><td><a href="#is_proper_list-1">is_proper_list/1</a></td><td>Returns <code>true</code> if <code>Node</code> represents a
  proper list, and <code>false</code> otherwise.</td></tr>
<tr><td><a href="#is_string-2">is_string/2</a></td><td>Returns <code>true</code> if <code>Node</code> has type
  <code>string</code> and represents <code>Value</code>, otherwise
  <code>false</code>.</td></tr>
<tr><td><a href="#is_tree-1">is_tree/1</a></td><td><em>For special purposes only</em>.</td></tr>
<tr><td><a href="#join_comments-2">join_comments/2</a></td><td>Appends the comments of <code>Source</code> to the current
  comments of <code>Target</code>.</td></tr>
<tr><td><a href="#list-1">list/1</a></td><td><a href="#list-2">See <code>list/2</code>.</a></td></tr>
<tr><td><a href="#list-2">list/2</a></td><td>Constructs an abstract list skeleton.</td></tr>
<tr><td><a href="#list_comp-2">list_comp/2</a></td><td>Creates an abstract list comprehension.</td></tr>
<tr><td><a href="#list_comp_body-1">list_comp_body/1</a></td><td>Returns the list of body subtrees of a <code>list_comp</code>
  node.</td></tr>
<tr><td><a href="#list_comp_template-1">list_comp_template/1</a></td><td>Returns the template subtree of a <code>list_comp</code> node.</td></tr>
<tr><td><a href="#list_elements-1">list_elements/1</a></td><td>Returns the list of element subtrees of a list skeleton.</td></tr>
<tr><td><a href="#list_head-1">list_head/1</a></td><td>Returns the head element subtree of a <code>list</code> node.</td></tr>
<tr><td><a href="#list_length-1">list_length/1</a></td><td>Returns the number of element subtrees of a list skeleton.</td></tr>
<tr><td><a href="#list_prefix-1">list_prefix/1</a></td><td>Returns the prefix element subtrees of a <code>list</code> node.</td></tr>
<tr><td><a href="#list_suffix-1">list_suffix/1</a></td><td>Returns the suffix subtree of a <code>list</code> node, if one
  exists.</td></tr>
<tr><td><a href="#list_tail-1">list_tail/1</a></td><td>Returns the tail of a <code>list</code> node.</td></tr>
<tr><td><a href="#macro-1">macro/1</a></td><td><a href="#macro-2">See <code>macro/2</code>.</a></td></tr>
<tr><td><a href="#macro-2">macro/2</a></td><td>Creates an abstract macro application.</td></tr>
<tr><td><a href="#macro_arguments-1">macro_arguments/1</a></td><td>Returns the list of argument subtrees of a <code>macro</code>
  node, if any.</td></tr>
<tr><td><a href="#macro_name-1">macro_name/1</a></td><td>Returns the name subtree of a <code>macro</code> node.</td></tr>
<tr><td><a href="#make_tree-2">make_tree/2</a></td><td>Creates a syntax tree with the given type and subtrees.</td></tr>
<tr><td><a href="#match_expr-2">match_expr/2</a></td><td>Creates an abstract match-expression.</td></tr>
<tr><td><a href="#match_expr_body-1">match_expr_body/1</a></td><td>Returns the body subtree of a <code>match_expr</code> node.</td></tr>
<tr><td><a href="#match_expr_pattern-1">match_expr_pattern/1</a></td><td>Returns the pattern subtree of a <code>match_expr</code> node.</td></tr>
<tr><td><a href="#meta-1">meta/1</a></td><td>Creates a meta-representation of a syntax tree.</td></tr>
<tr><td><a href="#module_qualifier-2">module_qualifier/2</a></td><td>Creates an abstract module qualifier.</td></tr>
<tr><td><a href="#module_qualifier_argument-1">module_qualifier_argument/1</a></td><td>Returns the argument (the module) subtree of a
  <code>module_qualifier</code> node.</td></tr>
<tr><td><a href="#module_qualifier_body-1">module_qualifier_body/1</a></td><td>Returns the body subtree of a <code>module_qualifier</code>
  node.</td></tr>
<tr><td><a href="#nil-0">nil/0</a></td><td>Creates an abstract empty list.</td></tr>
<tr><td><a href="#normalize_list-1">normalize_list/1</a></td><td>Expands an abstract list skeleton to its most explicit form.</td></tr>
<tr><td><a href="#operator-1">operator/1</a></td><td>Creates an abstract operator.</td></tr>
<tr><td><a href="#operator_literal-1">operator_literal/1</a></td><td>Returns the literal string represented by an
  <code>operator</code> node.</td></tr>
<tr><td><a href="#operator_name-1">operator_name/1</a></td><td>Returns the name of an <code>operator</code> node.</td></tr>
<tr><td><a href="#parentheses-1">parentheses/1</a></td><td>Creates an abstract parenthesised expression.</td></tr>
<tr><td><a href="#parentheses_body-1">parentheses_body/1</a></td><td>Returns the body subtree of a <code>parentheses</code> node.</td></tr>
<tr><td><a href="#prefix_expr-2">prefix_expr/2</a></td><td>Creates an abstract prefix operator expression.</td></tr>
<tr><td><a href="#prefix_expr_argument-1">prefix_expr_argument/1</a></td><td>Returns the argument subtree of a <code>prefix_expr</code>
  node.</td></tr>
<tr><td><a href="#prefix_expr_operator-1">prefix_expr_operator/1</a></td><td>Returns the operator subtree of a <code>prefix_expr</code>
  node.</td></tr>
<tr><td><a href="#query_expr-1">query_expr/1</a></td><td>Creates an abstract Mnemosyne query expression.</td></tr>
<tr><td><a href="#query_expr_body-1">query_expr_body/1</a></td><td>Returns the body subtree of a <code>query_expr</code> node.</td></tr>
<tr><td><a href="#receive_expr-1">receive_expr/1</a></td><td><a href="#receive_expr-3">See <code>receive_expr/3</code>.</a></td></tr>
<tr><td><a href="#receive_expr-3">receive_expr/3</a></td><td>Creates an abstract receive-expression.</td></tr>
<tr><td><a href="#receive_expr_action-1">receive_expr_action/1</a></td><td>Returns the list of action body subtrees of a
  <code>receive_expr</code> node.</td></tr>
<tr><td><a href="#receive_expr_clauses-1">receive_expr_clauses/1</a></td><td>Returns the list of clause subtrees of a
  <code>receive_expr</code> node.</td></tr>
<tr><td><a href="#receive_expr_timeout-1">receive_expr_timeout/1</a></td><td>Returns the timeout subtree of a <code>receive_expr</code> node,
  if any.</td></tr>
<tr><td><a href="#record_access-2">record_access/2</a></td><td><a href="#record_access-3">See <code>record_access/3</code>.</a></td></tr>
<tr><td><a href="#record_access-3">record_access/3</a></td><td>Creates an abstract record field access expression.</td></tr>
<tr><td><a href="#record_access_argument-1">record_access_argument/1</a></td><td>Returns the argument subtree of a <code>record_access</code>
  node.</td></tr>
<tr><td><a href="#record_access_field-1">record_access_field/1</a></td><td>Returns the field subtree of a <code>record_access</code>
  node.</td></tr>
<tr><td><a href="#record_access_type-1">record_access_type/1</a></td><td>Returns the type subtree of a <code>record_access</code> node,
  if any.</td></tr>
<tr><td><a href="#record_expr-2">record_expr/2</a></td><td><a href="#record_expr-3">See <code>record_expr/3</code>.</a></td></tr>
<tr><td><a href="#record_expr-3">record_expr/3</a></td><td>Creates an abstract record expression.</td></tr>
<tr><td><a href="#record_expr_argument-1">record_expr_argument/1</a></td><td>Returns the argument subtree of a <code>record_expr</code> node,
  if any.</td></tr>
<tr><td><a href="#record_expr_fields-1">record_expr_fields/1</a></td><td>Returns the list of field subtrees of a
  <code>record_expr</code> node.</td></tr>
<tr><td><a href="#record_expr_type-1">record_expr_type/1</a></td><td>Returns the type subtree of a <code>record_expr</code> node.</td></tr>
<tr><td><a href="#record_field-1">record_field/1</a></td><td><a href="#record_field-2">See <code>record_field/2</code>.</a></td></tr>
<tr><td><a href="#record_field-2">record_field/2</a></td><td>Creates an abstract record field specification.</td></tr>
<tr><td><a href="#record_field_name-1">record_field_name/1</a></td><td>Returns the name subtree of a <code>record_field</code> node.</td></tr>
<tr><td><a href="#record_field_value-1">record_field_value/1</a></td><td>Returns the value subtree of a <code>record_field</code> node,
  if any.</td></tr>
<tr><td><a href="#record_index_expr-2">record_index_expr/2</a></td><td>Creates an abstract record field index expression.</td></tr>
<tr><td><a href="#record_index_expr_field-1">record_index_expr_field/1</a></td><td>Returns the field subtree of a <code>record_index_expr</code>
  node.</td></tr>
<tr><td><a href="#record_index_expr_type-1">record_index_expr_type/1</a></td><td>Returns the type subtree of a <code>record_index_expr</code>
  node.</td></tr>
<tr><td><a href="#remove_comments-1">remove_comments/1</a></td><td>Clears the associated comments of <code>Node</code>.</td></tr>
<tr><td><a href="#revert-1">revert/1</a></td><td>Returns an <code>erl_parse</code>-compatible representation of a
  syntax tree, if possible.</td></tr>
<tr><td><a href="#revert_forms-1">revert_forms/1</a></td><td>Reverts a sequence of Erlang source code forms.</td></tr>
<tr><td><a href="#rule-2">rule/2</a></td><td>Creates an abstract Mnemosyne rule.</td></tr>
<tr><td><a href="#rule_arity-1">rule_arity/1</a></td><td>Returns the arity of a <code>rule</code> node.</td></tr>
<tr><td><a href="#rule_clauses-1">rule_clauses/1</a></td><td>Returns the list of clause subtrees of a <code>rule</code> node.</td></tr>
<tr><td><a href="#rule_name-1">rule_name/1</a></td><td>Returns the name subtree of a <code>rule</code> node.</td></tr>
<tr><td><a href="#set_ann-2">set_ann/2</a></td><td>Sets the list of user annotations of <code>Node</code> to
  <code>Annotations</code>.</td></tr>
<tr><td><a href="#set_attrs-2">set_attrs/2</a></td><td>Sets the attributes of <code>Node</code> to
  <code>Attributes</code>.</td></tr>
<tr><td><a href="#set_pos-2">set_pos/2</a></td><td>Sets the position information of <code>Node</code> to
  <code>Pos</code>.</td></tr>
<tr><td><a href="#set_postcomments-2">set_postcomments/2</a></td><td>Sets the post-comments of <code>Node</code> to
  <code>Comments</code>.</td></tr>
<tr><td><a href="#set_precomments-2">set_precomments/2</a></td><td>Sets the pre-comments of <code>Node</code> to
  <code>Comments</code>.</td></tr>
<tr><td><a href="#size_qualifier-2">size_qualifier/2</a></td><td>Creates an abstract size qualifier.</td></tr>
<tr><td><a href="#size_qualifier_argument-1">size_qualifier_argument/1</a></td><td>Returns the argument subtree (the size) of a
  <code>size_qualifier</code> node.</td></tr>
<tr><td><a href="#size_qualifier_body-1">size_qualifier_body/1</a></td><td>Returns the body subtree of a <code>size_qualifier</code>
  node.</td></tr>
<tr><td><a href="#string-1">string/1</a></td><td>Creates an abstract string literal.</td></tr>
<tr><td><a href="#string_literal-1">string_literal/1</a></td><td>Returns the literal string represented by a <code>string</code>
  node.</td></tr>
<tr><td><a href="#string_value-1">string_value/1</a></td><td>Returns the value represented by a <code>string</code> node.</td></tr>
<tr><td><a href="#subtrees-1">subtrees/1</a></td><td>Returns the grouped list of all subtrees of a syntax tree.</td></tr>
<tr><td><a href="#text-1">text/1</a></td><td>Creates an abstract piece of source code text.</td></tr>
<tr><td><a href="#text_string-1">text_string/1</a></td><td>Returns the character sequence represented by a
  <code>text</code> node.</td></tr>
<tr><td><a href="#tree-1">tree/1</a></td><td><a href="#tree-2">See <code>tree/2</code>.</a></td></tr>
<tr><td><a href="#tree-2">tree/2</a></td><td><em>For special purposes only</em>.</td></tr>
<tr><td><a href="#try_expr-2">try_expr/2</a></td><td>Creates an abstract try-expression.</td></tr>
<tr><td><a href="#try_expr_body-1">try_expr_body/1</a></td><td>Returns the body subtree of a <code>try_expr</code> node.</td></tr>
<tr><td><a href="#try_expr_clauses-1">try_expr_clauses/1</a></td><td>Returns the list of clause subtrees of a <code>try_expr</code>
  node.</td></tr>
<tr><td><a href="#tuple-1">tuple/1</a></td><td>Creates an abstract tuple.</td></tr>
<tr><td><a href="#tuple_elements-1">tuple_elements/1</a></td><td>Returns the list of element subtrees of a <code>tuple</code>
  node.</td></tr>
<tr><td><a href="#tuple_size-1">tuple_size/1</a></td><td>Returns the number of elements of a <code>tuple</code> node.</td></tr>
<tr><td><a href="#type-1">type/1</a></td><td>Returns the type tag of <code>Node</code>.</td></tr>
<tr><td><a href="#underscore-0">underscore/0</a></td><td>Creates an abstract universal pattern ("<code>_</code>").</td></tr>
<tr><td><a href="#update_tree-2">update_tree/2</a></td><td>Creates a syntax tree with the same type and attributes as the
  given tree.</td></tr>
<tr><td><a href="#variable-1">variable/1</a></td><td>Creates an abstract variable with the given name.</td></tr>
<tr><td><a href="#variable_literal-1">variable_literal/1</a></td><td>Returns the name of a <code>variable</code> node as a string.</td></tr>
<tr><td><a href="#variable_name-1">variable_name/1</a></td><td>Returns the name of a <code>variable</code> node as an atom.</td></tr>
<tr><td><a href="#warning_marker-1">warning_marker/1</a></td><td>Creates an abstract warning marker.</td></tr>
<tr><td><a href="#warning_marker_info-1">warning_marker_info/1</a></td><td>Returns the ErrorInfo structure of a <code>warning_marker</code>
  node.</td></tr>
<tr><th colspan="2" align="left">Internal Documented Functions</th></tr>
<tr><td><a href="#is_wrapper-1">is_wrapper/1</a></td><td>Returns <code>true</code> if the argument is a wrapper
  structure, otherwise <code>false</code>.</td></tr>
<tr><td><a href="#unwrap-1">unwrap/1</a></td><td>Removes any wrapper structure, if present.</td></tr>
<tr><td><a href="#wrap-1">wrap/1</a></td><td>Creates a wrapper structure around an <code>erl_parse</code>
  "parse tree".</td></tr>
</table>

<h2><a name="types">Data Types</a></h2>

<h3><a name="type-syntaxTree">syntaxTree()</a></h3>

 An abstract syntax tree. The
  <code>erl_parse</code> "parse tree" representation is a subset of the
  <code>syntaxTree()</code> representation.
 
  <p>Every abstract syntax tree has a <em>type</em>, given by the
  function <a href="#type-1"><code>type/1</code></a>.</p>
 

<h3><a name="type-syntaxTreeAttributes">syntaxTreeAttributes()</a></h3>

 This is an abstract representation of
  syntax tree node attributes; see the function <a href="#get_attrs-1"><code>get_attrs/1</code></a>.
 

<h3><a name="type-erl_parse">erl_parse()</a> = <a href="erl_parse.html#type-parse_tree">erl_parse:parse_tree()</a></h3>

 The "parse tree"
  representation built by the Erlang standard library parser
  <code>erl_parse</code>. This is a subset of the
  <a href="#type-syntaxTree"><code>syntaxTree</code></a> type.
 

<h2><a name="exported">Exported Functions</a></h2>

<h3><a name="abstract-1">abstract/1</a></h3>

<p><code>abstract(Term::term()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the syntax tree corresponding to an Erlang term.
  <code>Term</code> must be a literal term, i.e., one that can be
  represented as a source code literal. Thus, it may not contain a
  process identifier, port, reference, binary or function value as a
  subterm. The function recognises printable strings, in order to get a
  compact and readable representation. Evaluation fails with reason
  <code>badarg</code> if <code>Term</code> is not a literal term.
 </p>
<p>See also: <a href="#concrete-1"><code>concrete/1</code></a>, <a href="#is_literal-1"><code>is_literal/1</code></a>.</p>

<h3><a name="add_ann-2">add_ann/2</a></h3>

<p><code>add_ann(Annotation::term(), Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Appends the term <code>Annotation</code> to the list of user
  annotations of <code>Node</code>.
 
  <p>Note: this is equivalent to <code>set_ann(Node, [Annotation |
  get_ann(Node)])</code>, but potentially more efficient.</p>
 </p>
<p>See also: <a href="#get_ann-1"><code>get_ann/1</code></a>, <a href="#set_ann-2"><code>set_ann/2</code></a>.</p>

<h3><a name="add_postcomments-2">add_postcomments/2</a></h3>

<p><code>add_postcomments(Comments::[<a href="#type-syntaxTree">syntaxTree()</a>], Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Appends <code>Comments</code> to the post-comments of
  <code>Node</code>.
 
  <p>Note: This is equivalent to <code>set_postcomments(Node,
  get_postcomments(Node) ++ Comments)</code>, but potentially more
  efficient.</p>
 </p>
<p>See also: <a href="#add_precomments-2"><code>add_precomments/2</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#set_postcomments-2"><code>set_postcomments/2</code></a>.</p>

<h3><a name="add_precomments-2">add_precomments/2</a></h3>

<p><code>add_precomments(Comments::[<a href="#type-syntaxTree">syntaxTree()</a>], Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Appends <code>Comments</code> to the pre-comments of
  <code>Node</code>.
 
  <p>Note: This is equivalent to <code>set_precomments(Node,
  get_precomments(Node) ++ Comments)</code>, but potentially more
  efficient.</p>
 </p>
<p>See also: <a href="#add_postcomments-2"><code>add_postcomments/2</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>, <a href="#set_precomments-2"><code>set_precomments/2</code></a>.</p>

<h3><a name="application-2">application/2</a></h3>

<p><code>application(Operator::<a href="#type-syntaxTree">syntaxTree()</a>, Arguments::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract function application expression. If
  <code>Arguments</code> is <code>[A1, ..., An]</code>, the result
  represents "<code><em>Operator</em>(<em>A1</em>, ...,
  <em>An</em>)</code>".
 </p>
<p>See also: <a href="#application-3"><code>application/3</code></a>, <a href="#application_arguments-1"><code>application_arguments/1</code></a>, <a href="#application_operator-1"><code>application_operator/1</code></a>.</p>

<h3><a name="application-3">application/3</a></h3>

<p><code>application(Module, Function::<a href="#type-syntaxTree">syntaxTree()</a>, Arguments::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Module = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract function application expression. (Utility
  function.) If <code>Module</code> is <code>none</code>, this is
  call is equivalent to <code>application(Function,
  Arguments)</code>, otherwise it is equivalent to
  <code>application(module_qualifier(Module, Function),
  Arguments)</code>.
 </p>
<p>See also: <a href="#application-2"><code>application/2</code></a>, <a href="#module_qualifier-2"><code>module_qualifier/2</code></a>.</p>

<h3><a name="application_arguments-1">application_arguments/1</a></h3>

<p><code>application_arguments(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of argument subtrees of an
  <code>application</code> node.
 </p>
<p>See also: <a href="#application-2"><code>application/2</code></a>.</p>

<h3><a name="application_operator-1">application_operator/1</a></h3>

<p><code>application_operator(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the operator subtree of an <code>application</code>
  node.
 
  <p>Note: if <code>Node</code> represents
  "<code><em>M</em>:<em>F</em>(...)</code>", then the result is the
  subtree representing "<code><em>M</em>:<em>F</em></code>".</p>
 </p>
<p>See also: <a href="#application-2"><code>application/2</code></a>, <a href="#module_qualifier-2"><code>module_qualifier/2</code></a>.</p>

<h3><a name="arity_qualifier-2">arity_qualifier/2</a></h3>

<p><code>arity_qualifier(Body::<a href="#type-syntaxTree">syntaxTree()</a>, Arity::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract arity qualifier. The result represents
  "<code><em>Body</em>/<em>Arity</em></code>".
 </p>
<p>See also: <a href="#arity_qualifier_argument-1"><code>arity_qualifier_argument/1</code></a>, <a href="#arity_qualifier_body-1"><code>arity_qualifier_body/1</code></a>.</p>

<h3><a name="arity_qualifier_argument-1">arity_qualifier_argument/1</a></h3>

<p><code>arity_qualifier_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument (the arity) subtree of an
  <code>arity_qualifier</code> node.
 </p>
<p>See also: <a href="#arity_qualifier-1"><code>arity_qualifier/1</code></a>.</p>

<h3><a name="arity_qualifier_body-1">arity_qualifier_body/1</a></h3>

<p><code>arity_qualifier_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of an <code>arity_qualifier</code>
  node.
 </p>
<p>See also: <a href="#arity_qualifier-1"><code>arity_qualifier/1</code></a>.</p>

<h3><a name="atom-1">atom/1</a></h3>

<p><code>atom(Name) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Name = atom() | string()</li></ul></code></p>
<p>Creates an abstract atom literal. The print name of the atom is
  the character sequence represented by <code>Name</code>.
 </p>
<p>See also: <a href="#atom_literal-1"><code>atom_literal/1</code></a>, <a href="#atom_name-1"><code>atom_name/1</code></a>, <a href="#atom_value-1"><code>atom_value/1</code></a>, <a href="#is_atom-2"><code>is_atom/2</code></a>.</p>

<h3><a name="atom_literal-1">atom_literal/1</a></h3>

<p><code>atom_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the literal string represented by an <code>atom</code>
  node. This includes surrounding single-quote characters if necessary.
 
  <p>Note that e.g. the result of <code>atom("x\ny")</code> represents
  any and all of <code>'x\ny'</code>, <code>'x\12y'</code>,
  <code>'x\012y'</code> and <code>'x\^Jy\'</code>; cf.
  <code>string/1</code>.</p>
 </p>
<p>See also: <a href="#atom-1"><code>atom/1</code></a>, <a href="#string-1"><code>string/1</code></a>.</p>

<h3><a name="atom_name-1">atom_name/1</a></h3>

<p><code>atom_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the printname of an <code>atom</code> node.
 </p>
<p>See also: <a href="#atom-1"><code>atom/1</code></a>.</p>

<h3><a name="atom_value-1">atom_value/1</a></h3>

<p><code>atom_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> atom()</code></p>
<p>Returns the value represented by an <code>atom</code> node.
 </p>
<p>See also: <a href="#atom-1"><code>atom/1</code></a>.</p>

<h3><a name="attribute-1">attribute/1</a></h3>

<p><code>attribute(Name) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#attribute-2"><code>attribute(Name, none)</code></a>.</p>

<h3><a name="attribute-2">attribute/2</a></h3>

<p><code>attribute(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Arguments) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Arguments = none | [<a href="#type-syntaxTree">syntaxTree()</a>]</li></ul></code></p>
<p>Creates an abstract program attribute. If
  <code>Arguments</code> is <code>[A1, ..., An]</code>, the result
  represents "<code>-<em>Name</em>(<em>A1</em>, ...,
  <em>An</em>).</code>". Otherwise, if <code>Arguments</code> is
  <code>none</code>, the result represents
  "<code>-<em>Name</em>.</code>". The latter form makes it possible
  to represent preprocessor directives such as
  "<code>-endif.</code>". Attributes are source code forms.
 
  <p>Note: The preprocessor macro definition directive
  "<code>-define(<em>Name</em>, <em>Body</em>).</code>" has relatively
  few requirements on the syntactical form of <code>Body</code> (viewed
  as a sequence of tokens). The <code>text</code> node type can be used
  for a <code>Body</code> that is not a normal Erlang construct.</p>
 </p>
<p>See also: <a href="#attribute-1"><code>attribute/1</code></a>, <a href="#attribute_arguments-1"><code>attribute_arguments/1</code></a>, <a href="#attribute_name-1"><code>attribute_name/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#text-1"><code>text/1</code></a>.</p>

<h3><a name="attribute_arguments-1">attribute_arguments/1</a></h3>

<p><code>attribute_arguments(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of argument subtrees of an
  <code>attribute</code> node, if any. If <code>Node</code>
  represents "<code>-<em>Name</em>.</code>", the result is
  <code>none</code>. Otherwise, if <code>Node</code> represents
  "<code>-<em>Name</em>(<em>E1</em>, ..., <em>En</em>).</code>",
  <code>[E1, ..., E1]</code> is returned.
 </p>
<p>See also: <a href="#attribute-1"><code>attribute/1</code></a>.</p>

<h3><a name="attribute_name-1">attribute_name/1</a></h3>

<p><code>attribute_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the name subtree of an <code>attribute</code> node.
 </p>
<p>See also: <a href="#attribute-1"><code>attribute/1</code></a>.</p>

<h3><a name="binary-1">binary/1</a></h3>

<p><code>binary(Fields::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract binary-object template. If
  <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result
  represents "<code>&lt;&lt;<em>F1</em>, ...,
  <em>Fn</em>>></code>".
 </p>
<p>See also: <a href="#binary_field-2"><code>binary_field/2</code></a>, <a href="#binary_fields-1"><code>binary_fields/1</code></a>.</p>

<h3><a name="binary_field-1">binary_field/1</a></h3>

<p><code>binary_field(Body) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#binary_field-2"><code>binary_field(Body, [])</code></a>.</p>

<h3><a name="binary_field-2">binary_field/2</a></h3>

<p><code>binary_field(Body::<a href="#type-syntaxTree">syntaxTree()</a>, Types::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract binary template field. If
  <code>Types</code> is the empty list, the result simply represents
  "<code><em>Body</em></code>", otherwise, if <code>Types</code> is
  <code>[T1, ..., Tn]</code>, the result represents
  "<code><em>Body</em>/<em>T1</em>-...-<em>Tn</em></code>".
 </p>
<p>See also: <a href="#binary-1"><code>binary/1</code></a>, <a href="#binary_field-1"><code>binary_field/1</code></a>, <a href="#binary_field-3"><code>binary_field/3</code></a>, <a href="#binary_field_body-1"><code>binary_field_body/1</code></a>, <a href="#binary_field_size-1"><code>binary_field_size/1</code></a>, <a href="#binary_field_types-1"><code>binary_field_types/1</code></a>.</p>

<h3><a name="binary_field-3">binary_field/3</a></h3>

<p><code>binary_field(Body::<a href="#type-syntaxTree">syntaxTree()</a>, Size, Types::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Size = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract binary template field. (Utility function.)
  If <code>Size</code> is <code>none</code>, this is equivalent to
  "<code>binary_field(Body, Types)</code>", otherwise it is
  equivalent to "<code>binary_field(size_qualifier(Body, Size),
  Types)</code>".
 </p>
<p>See also: <a href="#binary-1"><code>binary/1</code></a>, <a href="#binary_field-2"><code>binary_field/2</code></a>, <a href="#size_qualifier-2"><code>size_qualifier/2</code></a>.</p>

<h3><a name="binary_field_body-1">binary_field_body/1</a></h3>

<p><code>binary_field_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>binary_field</code>.
 </p>
<p>See also: <a href="#binary_field-2"><code>binary_field/2</code></a>.</p>

<h3><a name="binary_field_size-1">binary_field_size/1</a></h3>

<p><code>binary_field_size(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the size specifier subtree of a
  <code>binary_field</code> node, if any. (Utility function.) If
  <code>Node</code> represents
  "<code><em>Body</em>:<em>Size</em></code>" or
  "<code><em>Body</em>:<em>Size</em>/<em>T1</em>, ...,
  <em>Tn</em></code>", the result is <code>Size</code>, otherwise
  <code>none</code> is returned.
 </p>
<p>See also: <a href="#binary_field-2"><code>binary_field/2</code></a>, <a href="#binary_field-3"><code>binary_field/3</code></a>.</p>

<h3><a name="binary_field_types-1">binary_field_types/1</a></h3>

<p><code>binary_field_types(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of type-specifier subtrees of a
  <code>binary_field</code> node. If <code>Node</code> represents
  "<code>.../<em>T1</em>, ..., <em>Tn</em></code>", the result is
  <code>[T1, ..., Tn]</code>, otherwise the result is the empty list.
 </p>
<p>See also: <a href="#binary_field-2"><code>binary_field/2</code></a>.</p>

<h3><a name="binary_fields-1">binary_fields/1</a></h3>

<p><code>binary_fields(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of field subtrees of a <code>binary</code>
  node.
 </p>
<p>See also: <a href="#binary-1"><code>binary/1</code></a>, <a href="#binary_field-2"><code>binary_field/2</code></a>.</p>

<h3><a name="block_expr-1">block_expr/1</a></h3>

<p><code>block_expr(Body::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract block expression. If <code>Body</code> is
  <code>[B1, ..., Bn]</code>, the result represents "<code>begin
  <em>B1</em>, ..., <em>Bn</em> end</code>".
 </p>
<p>See also: <a href="#block_expr_body-1"><code>block_expr_body/1</code></a>.</p>

<h3><a name="block_expr_body-1">block_expr_body/1</a></h3>

<p><code>block_expr_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of body subtrees of a <code>block_expr</code>
  node.
 </p>
<p>See also: <a href="#block_expr-1"><code>block_expr/1</code></a>.</p>

<h3><a name="case_expr-2">case_expr/2</a></h3>

<p><code>case_expr(Argument::<a href="#type-syntaxTree">syntaxTree()</a>, Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract case-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>case
  <em>Argument</em> of <em>C1</em>; ...; <em>Cn</em> end</code>". More
  exactly, if each <code>Ci</code> represents "<code>(<em>Pi</em>)
  <em>Gi</em> -> <em>Bi</em></code>", then the result represents
  "<code>case <em>Argument</em> of <em>P1</em> <em>G1</em> ->
  <em>B1</em>; ...; <em>Pn</em> <em>Gn</em> -> <em>Bn</em> end</code>".
 </p>
<p>See also: <a href="#case_expr_argument-1"><code>case_expr_argument/1</code></a>, <a href="#case_expr_clauses-1"><code>case_expr_clauses/1</code></a>, <a href="#clause-3"><code>clause/3</code></a>, <a href="#if_expr-1"><code>if_expr/1</code></a>.</p>

<h3><a name="case_expr_argument-1">case_expr_argument/1</a></h3>

<p><code>case_expr_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument subtree of a <code>case_expr</code> node.
 </p>
<p>See also: <a href="#case_expr-2"><code>case_expr/2</code></a>.</p>

<h3><a name="case_expr_clauses-1">case_expr_clauses/1</a></h3>

<p><code>case_expr_clauses(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of clause subtrees of a <code>case_expr</code>
  node.
 </p>
<p>See also: <a href="#case_expr-2"><code>case_expr/2</code></a>.</p>

<h3><a name="catch_expr-1">catch_expr/1</a></h3>

<p><code>catch_expr(Expr::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract catch-expression. The result represents
  "<code>catch <em>Expr</em></code>".
 </p>
<p>See also: <a href="#catch_expr_body-1"><code>catch_expr_body/1</code></a>.</p>

<h3><a name="catch_expr_body-1">catch_expr_body/1</a></h3>

<p><code>catch_expr_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>catch_expr</code> node.
 </p>
<p>See also: <a href="#catch_expr-1"><code>catch_expr/1</code></a>.</p>

<h3><a name="char-1">char/1</a></h3>

<p><code>char(Value::char()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract character literal. The result represents
  "<code>$<em>Name</em></code>", where <code>Name</code> corresponds to
  <code>Value</code>.
 
  <p>Note: the literal corresponding to a particular character value is
  not uniquely defined. E.g., the character "<code>a</code>" can be
  written both as "<code>$a</code>" and "<code>$\141</code>", and a Tab
  character can be written as "<code>$\11</code>", "<code>$\011</code>"
  or "<code>$\t</code>".</p>
 </p>
<p>See also: <a href="#char_literal-1"><code>char_literal/1</code></a>, <a href="#char_value-1"><code>char_value/1</code></a>, <a href="#is_char-2"><code>is_char/2</code></a>.</p>

<h3><a name="char_literal-1">char_literal/1</a></h3>

<p><code>char_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the literal string represented by a <code>char</code>
  node. This includes the leading "<code>$</code>" character.
 </p>
<p>See also: <a href="#char-1"><code>char/1</code></a>.</p>

<h3><a name="char_value-1">char_value/1</a></h3>

<p><code>char_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> char()</code></p>
<p>Returns the value represented by a <code>char</code> node.
 </p>
<p>See also: <a href="#char-1"><code>char/1</code></a>.</p>

<h3><a name="clause-2">clause/2</a></h3>

<p><code>clause(Guard, Body) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#clause-3"><code>clause([], Guard, Body)</code></a>.</p>

<h3><a name="clause-3">clause/3</a></h3>

<p><code>clause(Patterns::[<a href="#type-syntaxTree">syntaxTree()</a>], Guard, Body::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Guard = none | <a href="#type-syntaxTree">syntaxTree()</a> | [<a href="#type-syntaxTree">syntaxTree()</a>] | [[<a href="#type-syntaxTree">syntaxTree()</a>]]</li></ul></code></p>
<p>Creates an abstract clause. If <code>Patterns</code> is
  <code>[P1, ..., Pn]</code> and <code>Body</code> is <code>[B1, ...,
  Bm]</code>, then if <code>Guard</code> is <code>none</code>, the
  result represents "<code>(<em>P1</em>, ..., <em>Pn</em>) ->
  <em>B1</em>, ..., <em>Bm</em></code>", otherwise, unless
  <code>Guard</code> is a list, the result represents
  "<code>(<em>P1</em>, ..., <em>Pn</em>) when <em>Guard</em> ->
  <em>B1</em>, ..., <em>Bm</em></code>".
 
  <p>For simplicity, the <code>Guard</code> argument may also be any
  of the following:
  <ul>
    <li>An empty list <code>[]</code>. This is equivalent to passing
        <code>none</code>.</li>
    <li>A nonempty list <code>[E1, ..., Ej]</code> of syntax trees.
        This is equivalent to passing <code>conjunction([E1, ...,
        Ej])</code>.</li>
    <li>A nonempty list of lists of syntax trees <code>[[E1_1, ...,
        E1_k1], ..., [Ej_1, ..., Ej_kj]]</code>, which is equivalent
        to passing <code>disjunction([conjunction([E1_1, ...,
        E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</code>.</li>
  </ul>
  </p>
 </p>
<p>See also: <a href="#clause-2"><code>clause/2</code></a>, <a href="#clause_body-1"><code>clause_body/1</code></a>, <a href="#clause_guard-1"><code>clause_guard/1</code></a>, <a href="#clause_patterns-1"><code>clause_patterns/1</code></a>.</p>

<h3><a name="clause_body-1">clause_body/1</a></h3>

<p><code>clause_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Return the list of body subtrees of a <code>clause</code>
  node.
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>.</p>

<h3><a name="clause_guard-1">clause_guard/1</a></h3>

<p><code>clause_guard(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the guard subtree of a <code>clause</code> node, if
  any. If <code>Node</code> represents "<code>(<em>P1</em>, ...,
  <em>Pn</em>) when <em>Guard</em> -> <em>B1</em>, ...,
  <em>Bm</em></code>", <code>Guard</code> is returned. Otherwise, the
  result is <code>none</code>.
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>.</p>

<h3><a name="clause_patterns-1">clause_patterns/1</a></h3>

<p><code>clause_patterns(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of pattern subtrees of a <code>clause</code>
  node.
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>.</p>

<h3><a name="comment-1">comment/1</a></h3>

<p><code>comment(Strings) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#comment-2"><code>comment(none, Strings)</code></a>.</p>

<h3><a name="comment-2">comment/2</a></h3>

<p><code>comment(Padding, Strings::[string()]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Padding = none | integer()</li></ul></code></p>
<p>Creates an abstract comment with the given padding and text. If
  <code>Strings</code> is a (possibly empty) list
  <code>["<em>Txt1</em>", ..., "<em>TxtN</em>"]</code>, the result
  represents the source code text
  <pre>
      %<em>Txt1</em>
      ...
      %<em>TxtN</em></pre>
  <code>Padding</code> states the number of empty character positions
  to the left of the comment separating it horizontally from
  source code on the same line (if any). If <code>Padding</code> is
  <code>none</code>, a default positive number is used. If
  <code>Padding</code> is an integer less than 1, there should be no
  separating space. Comments are in themselves regarded as source
  program forms.
 </p>
<p>See also: <a href="#comment-1"><code>comment/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>.</p>

<h3><a name="comment_padding-1">comment_padding/1</a></h3>

<p><code>comment_padding(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | integer()</code></p>
<p>Returns the amount of padding before the comment, or
  <code>none</code>. The latter means that a default padding may be
  used.
 </p>
<p>See also: <a href="#comment-2"><code>comment/2</code></a>.</p>

<h3><a name="comment_text-1">comment_text/1</a></h3>

<p><code>comment_text(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [string()]</code></p>
<p>Returns the lines of text of the abstract comment.
 </p>
<p>See also: <a href="#comment-2"><code>comment/2</code></a>.</p>

<h3><a name="compact_list-1">compact_list/1</a></h3>

<p><code>compact_list(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Yields the most compact form for an abstract list skeleton. The
  result either represents "<code>[<em>E1</em>, ..., <em>En</em> |
  <em>Tail</em>]</code>", where <code>Tail</code> is not a list
  skeleton, or otherwise simply "<code>[<em>E1</em>, ...,
  <em>En</em>]</code>". Annotations on subtrees of <code>Node</code>
  that represent list skeletons may be lost, but comments will be
  propagated to the result. Returns <code>Node</code> itself if
  <code>Node</code> does not represent a list skeleton.
 </p>
<p>See also: <a href="#list-2"><code>list/2</code></a>, <a href="#normalize_list-1"><code>normalize_list/1</code></a>.</p>

<h3><a name="concrete-1">concrete/1</a></h3>

<p><code>concrete(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> term()</code></p>
<p>Returns the Erlang term represented by a syntax tree. Evaluation
  fails with reason <code>badarg</code> if <code>Node</code> does not
  represent a literal term.
 
  <p>Note: Currently, the set of syntax trees which have a concrete
  representation is larger than the set of trees which can be built
  using the function <code>abstract/1</code>. An abstract character
  will be concretised as an integer, while <code>abstract/1</code> does
  not at present yield an abstract character for any input. (Use the
  <code>char/1</code> function to explicitly create an abstract
  character.)</p>
 </p>
<p>See also: <a href="#abstract-1"><code>abstract/1</code></a>, <a href="#char-1"><code>char/1</code></a>, <a href="#is_literal-1"><code>is_literal/1</code></a>.</p>

<h3><a name="conjunction-1">conjunction/1</a></h3>

<p><code>conjunction(List::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract conjunction. If <code>List</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code><em>E1</em>, ..., <em>En</em></code>".
 </p>
<p>See also: <a href="#conjunction_body-1"><code>conjunction_body/1</code></a>, <a href="#disjunction-1"><code>disjunction/1</code></a>.</p>

<h3><a name="conjunction_body-1">conjunction_body/1</a></h3>

<p><code>conjunction_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of body subtrees of a
  <code>conjunction</code> node.
 </p>
<p>See also: <a href="#conjunction-1"><code>conjunction/1</code></a>.</p>

<h3><a name="cons-2">cons/2</a></h3>

<p><code>cons(Head::<a href="#type-syntaxTree">syntaxTree()</a>, Tail::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>"Optimising" list skeleton cons operation. Creates an abstract
  list skeleton whose first element is <code>Head</code> and whose tail
  corresponds to <code>Tail</code>. This is similar to
  <code>list([Head], Tail)</code>, except that <code>Tail</code> may
  not be <code>none</code>, and that the result does not necessarily
  represent exactly "<code>[<em>Head</em> | <em>Tail</em>]</code>", but
  may depend on the <code>Tail</code> subtree. E.g., if
  <code>Tail</code> represents <code>[X, Y]</code>, the result may
  represent "<code>[<em>Head</em>, X, Y]</code>", rather than
  "<code>[<em>Head</em> | [X, Y]]</code>". Annotations on
  <code>Tail</code> itself may be lost if <code>Tail</code> represents
  a list skeleton, but comments on <code>Tail</code> are propagated to
  the result.
 </p>
<p>See also: <a href="#list-2"><code>list/2</code></a>, <a href="#list_head-1"><code>list_head/1</code></a>, <a href="#list_tail-1"><code>list_tail/1</code></a>.</p>

<h3><a name="copy_ann-2">copy_ann/2</a></h3>

<p><code>copy_ann(Source::<a href="#type-syntaxTree">syntaxTree()</a>, Target::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Copies the list of user annotations from <code>Source</code> to
  <code>Target</code>.
 
  <p>Note: this is equivalent to <code>set_ann(Target,
  get_ann(Source))</code>, but potentially more efficient.</p>
 </p>
<p>See also: <a href="#get_ann-1"><code>get_ann/1</code></a>, <a href="#set_ann-2"><code>set_ann/2</code></a>.</p>

<h3><a name="copy_attrs-2">copy_attrs/2</a></h3>

<p><code>copy_attrs(Source::<a href="#type-syntaxTree">syntaxTree()</a>, Target::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Copies the attributes from <code>Source</code> to
  <code>Target</code>.
 
  <p>Note: this is equivalent to <code>set_attrs(Target,
  get_attrs(Source))</code>, but potentially more efficient.</p>
 </p>
<p>See also: <a href="#get_attrs-1"><code>get_attrs/1</code></a>, <a href="#set_attrs-2"><code>set_attrs/2</code></a>.</p>

<h3><a name="copy_comments-2">copy_comments/2</a></h3>

<p><code>copy_comments(Source::<a href="#type-syntaxTree">syntaxTree()</a>, Target::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Copies the pre- and postcomments from <code>Source</code> to
  <code>Target</code>.
 
  <p>Note: This is equivalent to
  <code>set_postcomments(set_precomments(Target,
  get_precomments(Source)), get_postcomments(Source))</code>, but
  potentially more efficient.</p>
 </p>
<p>See also: <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>, <a href="#set_postcomments-2"><code>set_postcomments/2</code></a>, <a href="#set_precomments-2"><code>set_precomments/2</code></a>.</p>

<h3><a name="copy_pos-2">copy_pos/2</a></h3>

<p><code>copy_pos(Source::<a href="#type-syntaxTree">syntaxTree()</a>, Target::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Copies the position information from <code>Source</code> to
  <code>Target</code>.
 
  <p>This is equivalent to <code>set_pos(Target,
  get_pos(Source))</code>, but potentially more efficient.</p>
 </p>
<p>See also: <a href="#get_pos-1"><code>get_pos/1</code></a>, <a href="#set_pos-2"><code>set_pos/2</code></a>.</p>

<h3><a name="data-1">data/1</a></h3>

<p><code>data(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -> term()</code></p>
<p><em>For special purposes only</em>. Returns the associated data
  of a syntax tree node. Evaluation fails with reason
  <code>badarg</code> if <code>is_tree(Node)</code> does not yield
  <code>true</code>.
 </p>
<p>See also: <a href="#tree-2"><code>tree/2</code></a>.</p>

<h3><a name="disjunction-1">disjunction/1</a></h3>

<p><code>disjunction(List::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract disjunction. If <code>List</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code><em>E1</em>; ...; <em>En</em></code>".
 </p>
<p>See also: <a href="#conjunction-1"><code>conjunction/1</code></a>, <a href="#disjunction_body-1"><code>disjunction_body/1</code></a>.</p>

<h3><a name="disjunction_body-1">disjunction_body/1</a></h3>

<p><code>disjunction_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of body subtrees of a
  <code>disjunction</code> node.
 </p>
<p>See also: <a href="#disjunction-1"><code>disjunction/1</code></a>.</p>

<h3><a name="eof_marker-0">eof_marker/0</a></h3>

<p><code>eof_marker() -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract end-of-file marker. This represents the
  end of input when reading a sequence of source code forms. An
  end-of-file marker is itself regarded as a source code form
  (namely, the last in any sequence in which it occurs). It has no
  defined lexical form.
 
  <p>Note: this is retained only for backwards compatibility with
  existing parsers and tools.</p>
 </p>
<p>See also: <a href="#error_marker-1"><code>error_marker/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#warning_marker-1"><code>warning_marker/1</code></a>.</p>

<h3><a name="error_marker-1">error_marker/1</a></h3>

<p><code>error_marker(Error::term()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract error marker. The result represents an
  occurrence of an error in the source code, with an associated Erlang
  I/O ErrorInfo structure given by <code>Error</code> (see module
  <code>io</code> for details). Error markers are regarded as source
  code forms, but have no defined lexical form.
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.</p>
 </p>
<p>See also: <a href="io.html"><code>io</code></a>, <a href="#eof_marker-0"><code>eof_marker/0</code></a>, <a href="#error_marker_info-1"><code>error_marker_info/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#warning_marker-1"><code>warning_marker/1</code></a>.</p>

<h3><a name="error_marker_info-1">error_marker_info/1</a></h3>

<p><code>error_marker_info(<a href="#type-syntaxTree">syntaxTree()</a>) -> term()</code></p>
<p>Returns the ErrorInfo structure of an <code>error_marker</code>
  node.
 </p>
<p>See also: <a href="#error_marker-1"><code>error_marker/1</code></a>.</p>

<h3><a name="flatten_form_list-1">flatten_form_list/1</a></h3>

<p><code>flatten_form_list(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Flattens sublists of a <code>form_list</code> node. Returns
  <code>Node</code> with all subtrees of type <code>form_list</code>
  recursively expanded, yielding a single "flat" abstract form
  sequence.
 </p>
<p>See also: <a href="#form_list-1"><code>form_list/1</code></a>.</p>

<h3><a name="float-1">float/1</a></h3>

<p><code>float(Value::float()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract floating-point literal. The lexical
  representation is the decimal floating-point numeral of
  <code>Value</code>.
 </p>
<p>See also: <a href="#float_literal-1"><code>float_literal/1</code></a>, <a href="#float_value-1"><code>float_value/1</code></a>.</p>

<h3><a name="float_literal-1">float_literal/1</a></h3>

<p><code>float_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the numeral string represented by a <code>float</code>
  node.
 </p>
<p>See also: <a href="#float-1"><code>float/1</code></a>.</p>

<h3><a name="float_value-1">float_value/1</a></h3>

<p><code>float_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> float()</code></p>
<p>Returns the value represented by a <code>float</code> node. Note
  that floating-point values should usually not be compared for
  equality.
 </p>
<p>See also: <a href="#float-1"><code>float/1</code></a>.</p>

<h3><a name="form_list-1">form_list/1</a></h3>

<p><code>form_list(Forms::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract sequence of "source code forms". If
  <code>Forms</code> is <code>[F1, ..., Fn]</code>, where each
  <code>Fi</code> is a form (cf. <code>is_form/1</code>, the result
  represents
  <pre>
      <em>F1</em>
      ...
      <em>Fn</em></pre>
  where the <code>Fi</code> are separated by one or more line breaks. A
  node of type <code>form_list</code> is itself regarded as a source
  code form; cf. <code>flatten_form_list/1</code>.
 
  <p>Note: this is simply a way of grouping source code forms as a
  single syntax tree, usually in order to form an Erlang module
  definition.</p>
 </p>
<p>See also: <a href="#flatten_form_list-1"><code>flatten_form_list/1</code></a>, <a href="#form_list_elements-1"><code>form_list_elements/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>.</p>

<h3><a name="form_list_elements-1">form_list_elements/1</a></h3>

<p><code>form_list_elements(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of subnodes of a <code>form_list</code> node.
 </p>
<p>See also: <a href="#form_list-1"><code>form_list/1</code></a>.</p>

<h3><a name="fun_expr-1">fun_expr/1</a></h3>

<p><code>fun_expr(Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract fun-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>fun
  <em>C1</em>; ...; <em>Cn</em> end</code>". More exactly, if each
  <code>Ci</code> represents "<code>(<em>Pi1</em>, ..., <em>Pim</em>)
  <em>Gi</em> -> <em>Bi</em></code>", then the result represents
  "<code>fun (<em>P11</em>, ..., <em>P1m</em>) <em>G1</em> ->
  <em>B1</em>; ...; (<em>Pn1</em>, ..., <em>Pnm</em>) <em>Gn</em> ->
  <em>Bn</em> end</code>".
 </p>
<p>See also: <a href="#fun_expr_arity-1"><code>fun_expr_arity/1</code></a>, <a href="#fun_expr_clauses-1"><code>fun_expr_clauses/1</code></a>.</p>

<h3><a name="fun_expr_arity-1">fun_expr_arity/1</a></h3>

<p><code>fun_expr_arity(<a href="#type-syntaxTree">syntaxTree()</a>) -> integer()</code></p>
<p>Returns the arity of a <code>fun_expr</code> node. The result is
  the number of parameter patterns in the first clause of the
  fun-expression; subsequent clauses are ignored.
 
  <p>An exception is thrown if <code>fun_expr_clauses(Node)</code>
  returns an empty list, or if the first element of that list is not a
  syntax tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>, <a href="#clause_patterns-1"><code>clause_patterns/1</code></a>, <a href="#fun_expr-1"><code>fun_expr/1</code></a>, <a href="#fun_expr_clauses-1"><code>fun_expr_clauses/1</code></a>.</p>

<h3><a name="fun_expr_clauses-1">fun_expr_clauses/1</a></h3>

<p><code>fun_expr_clauses(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of clause subtrees of a <code>fun_expr</code>
  node.
 </p>
<p>See also: <a href="#fun_expr-1"><code>fun_expr/1</code></a>.</p>

<h3><a name="function-2">function/2</a></h3>

<p><code>function(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract function definition. If <code>Clauses</code>
  is <code>[C1, ..., Cn]</code>, the result represents
  "<code><em>Name</em> <em>C1</em>; ...; <em>Name</em>
  <em>Cn</em>.</code>". More exactly, if each <code>Ci</code>
  represents "<code>(<em>Pi1</em>, ..., <em>Pim</em>) <em>Gi</em> ->
  <em>Bi</em></code>", then the result represents
  "<code><em>Name</em>(<em>P11</em>, ..., <em>P1m</em>) <em>G1</em> ->
  <em>B1</em>; ...; <em>Name</em>(<em>Pn1</em>, ..., <em>Pnm</em>)
  <em>Gn</em> -> <em>Bn</em>.</code>". Function definitions are source
  code forms.
 </p>
<p>See also: <a href="#function_arity-1"><code>function_arity/1</code></a>, <a href="#function_clauses-1"><code>function_clauses/1</code></a>, <a href="#function_name-1"><code>function_name/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#rule-2"><code>rule/2</code></a>.</p>

<h3><a name="function_arity-1">function_arity/1</a></h3>

<p><code>function_arity(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> integer()</code></p>
<p>Returns the arity of a <code>function</code> node. The result
  is the number of parameter patterns in the first clause of the
  function; subsequent clauses are ignored.
 
  <p>An exception is thrown if <code>function_clauses(Node)</code>
  returns an empty list, or if the first element of that list is not
  a syntax tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>, <a href="#clause_patterns-1"><code>clause_patterns/1</code></a>, <a href="#function-2"><code>function/2</code></a>, <a href="#function_clauses-1"><code>function_clauses/1</code></a>.</p>

<h3><a name="function_clauses-1">function_clauses/1</a></h3>

<p><code>function_clauses(Arg1) -> term()</code></p>
<p>Returns the list of clause subtrees of a <code>function</code>
  node.
 </p>
<p>See also: <a href="#function-2"><code>function/2</code></a>.</p>

<h3><a name="function_name-1">function_name/1</a></h3>

<p><code>function_name(Arg1) -> term()</code></p>
<p>Returns the name subtree of a <code>function</code> node.
 </p>
<p>See also: <a href="#function-2"><code>function/2</code></a>.</p>

<h3><a name="generator-2">generator/2</a></h3>

<p><code>generator(Pattern::<a href="#type-syntaxTree">syntaxTree()</a>, Body::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract generator. The result represents
  "<code><em>Pattern</em> &lt;- <em>Body</em></code>".
 </p>
<p>See also: <a href="#generator_body-1"><code>generator_body/1</code></a>, <a href="#generator_pattern-1"><code>generator_pattern/1</code></a>, <a href="#list_comp-2"><code>list_comp/2</code></a>.</p>

<h3><a name="generator_body-1">generator_body/1</a></h3>

<p><code>generator_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>generator</code> node.
 </p>
<p>See also: <a href="#generator-2"><code>generator/2</code></a>.</p>

<h3><a name="generator_pattern-1">generator_pattern/1</a></h3>

<p><code>generator_pattern(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the pattern subtree of a <code>generator</code> node.
 </p>
<p>See also: <a href="#generator-2"><code>generator/2</code></a>.</p>

<h3><a name="get_ann-1">get_ann/1</a></h3>

<p><code>get_ann(<a href="#type-syntaxTree">syntaxTree()</a>) -> [term()]</code></p>
<p>Returns the list of user annotations associated with a syntax
  tree node. For a newly created node, this is the empty list. The
  annotations may be any terms.
 </p>
<p>See also: <a href="#set_ann-2"><code>set_ann/2</code></a>.</p>

<h3><a name="get_attrs-1">get_attrs/1</a></h3>

<p><code>get_attrs(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTreeAttributes">syntaxTreeAttributes()</a></code></p>
<p>Returns a representation of the attributes associated with a
  syntax tree node. The attributes are all the extra information that
  can be attached to a node. Currently, this includes position
  information, source code comments, and user annotations.
 </p>
<p>See also: <a href="#get_ann-1"><code>get_ann/1</code></a>, <a href="#get_pos-1"><code>get_pos/1</code></a>, <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>, <a href="#set_attrs-2"><code>set_attrs/2</code></a>.</p>

<h3><a name="get_pos-1">get_pos/1</a></h3>

<p><code>get_pos(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> term()</code></p>
<p>Returns the position information associated with
  <code>Node</code>. This is usually a nonnegative integer, but may be
  any term. By default, all new tree nodes have their associated
  position information set to the integer zero.
 </p>
<p>See also: <a href="#set_pos-2"><code>set_pos/2</code></a>.</p>

<h3><a name="get_postcomments-1">get_postcomments/1</a></h3>

<p><code>get_postcomments(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the associated post-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
 </p>
<p>See also: <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>, <a href="#set_postcomments-2"><code>set_postcomments/2</code></a>.</p>

<h3><a name="get_precomments-1">get_precomments/1</a></h3>

<p><code>get_precomments(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the associated pre-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
 </p>
<p>See also: <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#set_precomments-2"><code>set_precomments/2</code></a>.</p>

<h3><a name="has_comments-1">has_comments/1</a></h3>

<p><code>has_comments(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Yields <code>false</code> if the node has no associated
  comments, and <code>true</code> otherwise.
 
  <p>Note: This is equivalent to <code>(get_precomments(Node) == [])
  and (get_postcomments(Node) == [])</code>, but potentially more
  efficient.</p>
 </p>
<p>See also: <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>.</p>

<h3><a name="if_expr-1">if_expr/1</a></h3>

<p><code>if_expr(Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract if-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>if
  <em>C1</em>; ...; <em>Cn</em> end</code>". More exactly, if each
  <code>Ci</code> represents "<code>() <em>Gi</em> ->
  <em>Bi</em></code>", then the result represents "<code>if
  <em>G1</em> -> <em>B1</em>; ...; <em>Gn</em> -> <em>Bn</em>
  end</code>".
 </p>
<p>See also: <a href="#case_expr-2"><code>case_expr/2</code></a>, <a href="#clause-3"><code>clause/3</code></a>, <a href="#if_expr_clauses-1"><code>if_expr_clauses/1</code></a>.</p>

<h3><a name="if_expr_clauses-1">if_expr_clauses/1</a></h3>

<p><code>if_expr_clauses(Arg1) -> term()</code></p>
<p>Returns the list of clause subtrees of an <code>if_expr</code>
  node.
 </p>
<p>See also: <a href="#if_expr-1"><code>if_expr/1</code></a>.</p>

<h3><a name="implicit_fun-1">implicit_fun/1</a></h3>

<p><code>implicit_fun(Name::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract "implicit fun" expression. The result
  represents "<code>fun <em>Name</em></code>".
 </p>
<p>See also: <a href="#implicit_fun-2"><code>implicit_fun/2</code></a>, <a href="#implicit_fun_name-1"><code>implicit_fun_name/1</code></a>.</p>

<h3><a name="implicit_fun-2">implicit_fun/2</a></h3>

<p><code>implicit_fun(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Arity::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract "implicit fun" expression. (Utility
  function.) If <code>Arity</code> is <code>none</code>, this is
  equivalent to <code>implicit_fun(Name)</code>, otherwise it is
  equivalent to <code>implicit_fun(arity_qualifier(Name,
  Arity))</code>.
 </p>
<p>See also: <a href="#implicit_fun-1"><code>implicit_fun/1</code></a>.</p>

<h3><a name="implicit_fun_name-1">implicit_fun_name/1</a></h3>

<p><code>implicit_fun_name(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the name subtree of an <code>implicit_fun</code> node.
 
  <p>Note: if <code>Node</code> represents "<code>fun
  <em>N</em>/<em>A</em></code>", then the result is the subtree
  representing "<code><em>N</em>/<em>A</em></code>".</p>
 </p>
<p>See also: <a href="#implicit_fun-1"><code>implicit_fun/1</code></a>.</p>

<h3><a name="infix_expr-3">infix_expr/3</a></h3>

<p><code>infix_expr(Left::<a href="#type-syntaxTree">syntaxTree()</a>, Operator::<a href="#type-syntaxTree">syntaxTree()</a>, Right::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract infix operator expression. The result
  represents "<code><em>Left</em> <em>Operator</em>
  <em>Right</em></code>".
 </p>
<p>See also: <a href="#infix_expr_left-1"><code>infix_expr_left/1</code></a>, <a href="#infix_expr_operator-1"><code>infix_expr_operator/1</code></a>, <a href="#infix_expr_right-1"><code>infix_expr_right/1</code></a>, <a href="#prefix_expr-2"><code>prefix_expr/2</code></a>.</p>

<h3><a name="infix_expr_left-1">infix_expr_left/1</a></h3>

<p><code>infix_expr_left(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the left argument subtree of an
  <code>infix_expr</code> node.
 </p>
<p>See also: <a href="#infix_expr-3"><code>infix_expr/3</code></a>.</p>

<h3><a name="infix_expr_operator-1">infix_expr_operator/1</a></h3>

<p><code>infix_expr_operator(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the operator subtree of an <code>infix_expr</code>
  node.
 </p>
<p>See also: <a href="#infix_expr-3"><code>infix_expr/3</code></a>.</p>

<h3><a name="infix_expr_right-1">infix_expr_right/1</a></h3>

<p><code>infix_expr_right(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the right argument subtree of an
  <code>infix_expr</code> node.
 </p>
<p>See also: <a href="#infix_expr-3"><code>infix_expr/3</code></a>.</p>

<h3><a name="integer-1">integer/1</a></h3>

<p><code>integer(Value::integer()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract integer literal. The lexical representation
  is the canonical decimal numeral of <code>Value</code>.
 </p>
<p>See also: <a href="#integer_literal-1"><code>integer_literal/1</code></a>, <a href="#integer_value-1"><code>integer_value/1</code></a>, <a href="#is_integer-2"><code>is_integer/2</code></a>.</p>

<h3><a name="integer_literal-1">integer_literal/1</a></h3>

<p><code>integer_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the numeral string represented by an
  <code>integer</code> node.
 </p>
<p>See also: <a href="#integer-1"><code>integer/1</code></a>.</p>

<h3><a name="integer_value-1">integer_value/1</a></h3>

<p><code>integer_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> integer()</code></p>
<p>Returns the value represented by an <code>integer</code> node.
 </p>
<p>See also: <a href="#integer-1"><code>integer/1</code></a>.</p>

<h3><a name="is_atom-2">is_atom/2</a></h3>

<p><code>is_atom(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Value::atom()) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> has type
  <code>atom</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p>See also: <a href="#atom-1"><code>atom/1</code></a>.</p>

<h3><a name="is_char-2">is_char/2</a></h3>

<p><code>is_char(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Value::char()) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> has type
  <code>char</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p>See also: <a href="#char-1"><code>char/1</code></a>.</p>

<h3><a name="is_form-1">is_form/1</a></h3>

<p><code>is_form(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> is a syntax tree
  representing a so-called "source code form", otherwise
  <code>false</code>. Forms are the Erlang source code units which,
  placed in sequence, constitute an Erlang program. Current form types
  are:
  <p><center><table border="1">
   <tr>
    <td><code>attribute</code></td>
    <td><code>comment</code></td>
    <td><code>error_marker</code></td>
    <td><code>eof_marker</code></td>
   </tr><tr>
    <td><code>form_list</code></td>
    <td><code>function</code></td>
    <td><code>rule</code></td>
    <td><code>warning_marker</code></td>
   </tr>
  </table></center></p></p>
<p>See also: <a href="#attribute-2"><code>attribute/2</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#eof_marker-1"><code>eof_marker/1</code></a>, <a href="#error_marker-1"><code>error_marker/1</code></a>, <a href="#form_list-1"><code>form_list/1</code></a>, <a href="#function-2"><code>function/2</code></a>, <a href="#rule-2"><code>rule/2</code></a>, <a href="#type-1"><code>type/1</code></a>, <a href="#warning_marker-1"><code>warning_marker/1</code></a>.</p>

<h3><a name="is_integer-2">is_integer/2</a></h3>

<p><code>is_integer(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Value::integer()) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> has type
  <code>integer</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p>See also: <a href="#integer-1"><code>integer/1</code></a>.</p>

<h3><a name="is_leaf-1">is_leaf/1</a></h3>

<p><code>is_leaf(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> is a leaf node,
  otherwise <code>false</code>. The currently recognised leaf node
  types are:
  <p><center><table border="1">
   <tr>
    <td><code>atom</code></td>
    <td><code>char</code></td>
    <td><code>comment</code></td>
    <td><code>eof_marker</code></td>
    <td><code>error_marker</code></td>
   </tr><tr>
    <td><code>float</code></td>
    <td><code>integer</code></td>
    <td><code>nil</code></td>
    <td><code>operator</code></td>
    <td><code>string</code></td>
   </tr><tr>
    <td><code>text</code></td>
    <td><code>underscore</code></td>
    <td><code>variable</code></td>
    <td><code>warning_marker</code></td>
   </tr>
  </table></center></p>
  <p>A node of type <code>tuple</code> is a leaf node if and only if
  its arity is zero.</p>
 
  <p>Note: not all literals are leaf nodes, and vice versa. E.g.,
  tuples with nonzero arity and nonempty lists may be literals, but are
  not leaf nodes. Variables, on the other hand, are leaf nodes but not
  literals.</p>
 </p>
<p>See also: <a href="#is_literal-1"><code>is_literal/1</code></a>, <a href="#type-1"><code>type/1</code></a>.</p>

<h3><a name="is_list_skeleton-1">is_list_skeleton/1</a></h3>

<p><code>is_list_skeleton(<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> has type
  <code>list</code> or <code>nil</code>, otherwise <code>false</code>.
 </p>
<p>See also: <a href="#list-2"><code>list/2</code></a>, <a href="#nil-0"><code>nil/0</code></a>.</p>

<h3><a name="is_literal-1">is_literal/1</a></h3>

<p><code>is_literal(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> represents a
  literal term, otherwise <code>false</code>. This function returns
  <code>true</code> if and only if the value of
  <code>concrete(Node)</code> is defined.
 </p>
<p>See also: <a href="#abstract-1"><code>abstract/1</code></a>, <a href="#concrete-1"><code>concrete/1</code></a>.</p>

<h3><a name="is_proper_list-1">is_proper_list/1</a></h3>

<p><code>is_proper_list(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> represents a
  proper list, and <code>false</code> otherwise. A proper list is a
  list skeleton either on the form "<code>[]</code>" or
  "<code>[<em>E1</em>, ..., <em>En</em>]</code>", or "<code>[... |
  <em>Tail</em>]</code>" where recursively <code>Tail</code> also
  represents a proper list.
 
  <p>Note: Since <code>Node</code> is a syntax tree, the actual
  run-time values corresponding to its subtrees may often be partially
  or completely unknown. Thus, if <code>Node</code> represents e.g.
  "<code>[... | Ns]</code>" (where <code>Ns</code> is a variable), then
  the function will return <code>false</code>, because it is not known
  whether <code>Ns</code> will be bound to a list at run-time. If
  <code>Node</code> instead represents e.g. "<code>[1, 2, 3]</code>" or
  "<code>[A | []]</code>", then the function will return
  <code>true</code>.</p>
 </p>
<p>See also: <a href="#list-2"><code>list/2</code></a>.</p>

<h3><a name="is_string-2">is_string/2</a></h3>

<p><code>is_string(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Value::string()) -> bool()</code></p>
<p>Returns <code>true</code> if <code>Node</code> has type
  <code>string</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p>See also: <a href="#string-1"><code>string/1</code></a>.</p>

<h3><a name="is_tree-1">is_tree/1</a></h3>

<p><code>is_tree(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -> bool()</code></p>
<p><em>For special purposes only</em>. Returns <code>true</code> if
  <code>Tree</code> is an abstract syntax tree and <code>false</code>
  otherwise.
 
  <p><em>Note</em>: this function yields <code>false</code> for all
  "old-style" <code>erl_parse</code>-compatible "parse trees".</p>
 </p>
<p>See also: <a href="#tree-2"><code>tree/2</code></a>.</p>

<h3><a name="join_comments-2">join_comments/2</a></h3>

<p><code>join_comments(Source::<a href="#type-syntaxTree">syntaxTree()</a>, Target::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Appends the comments of <code>Source</code> to the current
  comments of <code>Target</code>.
 
  <p>Note: This is equivalent to
  <code>add_postcomments(get_postcomments(Source),
  add_precomments(get_precomments(Source), Target))</code>, but
  potentially more efficient.</p></p>

<h3><a name="list-1">list/1</a></h3>

<p><code>list(List) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#list-2"><code>list(List, none)</code></a>.</p>

<h3><a name="list-2">list/2</a></h3>

<p><code>list(List, Tail) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>List = [<a href="#type-syntaxTree">syntaxTree()</a>]</li><li>Tail = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Constructs an abstract list skeleton. The result has type
  <code>list</code> or <code>nil</code>. If <code>List</code> is a
  nonempty list <code>[E1, ..., En]</code>, the result has type
  <code>list</code> and represents either "<code>[<em>E1</em>, ...,
  <em>En</em>]</code>", if <code>Tail</code> is <code>none</code>, or
  otherwise "<code>[<em>E1</em>, ..., <em>En</em> |
  <em>Tail</em>]</code>". If <code>List</code> is the empty list,
  <code>Tail</code> <em>must</em> be <code>none</code>, and in that
  case the result has type <code>nil</code> and represents
  "<code>[]</code>" (cf. <code>nil/0</code>).
 
  <p>The difference between lists as semantic objects (built up of
  individual "cons" and "nil" terms) and the various syntactic forms
  for denoting lists may be bewildering at first. This module provides
  functions both for exact control of the syntactic representation as
  well as for the simple composition and deconstruction in terms of
  cons and head/tail operations.</p>
 
  <p>Note: in <code>list(Elements, none)</code>, the "nil" list
  terminator is implicit and has no associated information (cf.
  <code>get_attrs/1</code>), while in the seemingly equivalent
  <code>list(Elements, Tail)</code> when <code>Tail</code> has type
  <code>nil</code>, the list terminator subtree <code>Tail</code> may
  have attached attributes such as position, comments, and annotations,
  which will be preserved in the result.</p>
 </p>
<p>See also: <a href="#compact_list-1"><code>compact_list/1</code></a>, <a href="#cons-2"><code>cons/2</code></a>, <a href="#get_attrs-1"><code>get_attrs/1</code></a>, <a href="#is_list_skeleton-1"><code>is_list_skeleton/1</code></a>, <a href="#is_proper_list-1"><code>is_proper_list/1</code></a>, <a href="#list-1"><code>list/1</code></a>, <a href="#list_elements-1"><code>list_elements/1</code></a>, <a href="#list_head-1"><code>list_head/1</code></a>, <a href="#list_length-1"><code>list_length/1</code></a>, <a href="#list_prefix-1"><code>list_prefix/1</code></a>, <a href="#list_suffix-1"><code>list_suffix/1</code></a>, <a href="#list_tail-1"><code>list_tail/1</code></a>, <a href="#nil-0"><code>nil/0</code></a>, <a href="#normalize_list-1"><code>normalize_list/1</code></a>.</p>

<h3><a name="list_comp-2">list_comp/2</a></h3>

<p><code>list_comp(Template::<a href="#type-syntaxTree">syntaxTree()</a>, Body::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract list comprehension. If <code>Body</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code>[<em>Template</em> || <em>E1</em>, ..., <em>En</em>]</code>".
 </p>
<p>See also: <a href="#generator-2"><code>generator/2</code></a>, <a href="#list_comp_body-1"><code>list_comp_body/1</code></a>, <a href="#list_comp_template-1"><code>list_comp_template/1</code></a>.</p>

<h3><a name="list_comp_body-1">list_comp_body/1</a></h3>

<p><code>list_comp_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of body subtrees of a <code>list_comp</code>
  node.
 </p>
<p>See also: <a href="#list_comp-2"><code>list_comp/2</code></a>.</p>

<h3><a name="list_comp_template-1">list_comp_template/1</a></h3>

<p><code>list_comp_template(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the template subtree of a <code>list_comp</code> node.
 </p>
<p>See also: <a href="#list_comp-2"><code>list_comp/2</code></a>.</p>

<h3><a name="list_elements-1">list_elements/1</a></h3>

<p><code>list_elements(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of element subtrees of a list skeleton.
  <code>Node</code> must represent a proper list. E.g., if
  <code>Node</code> represents "<code>[<em>X1</em>, <em>X2</em> |
  [<em>X3</em>, <em>X4</em> | []]</code>", then
  <code>list_elements(Node)</code> yields the list <code>[X1, X2, X3,
  X4]</code>.
 </p>
<p>See also: <a href="#is_proper_list-1"><code>is_proper_list/1</code></a>, <a href="#list-2"><code>list/2</code></a>.</p>

<h3><a name="list_head-1">list_head/1</a></h3>

<p><code>list_head(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the head element subtree of a <code>list</code> node. If
  <code>Node</code> represents "<code>[<em>Head</em> ...]</code>", the
  result will represent "<code><em>Head</em></code>".
 </p>
<p>See also: <a href="#cons-2"><code>cons/2</code></a>, <a href="#list-2"><code>list/2</code></a>, <a href="#list_tail-1"><code>list_tail/1</code></a>.</p>

<h3><a name="list_length-1">list_length/1</a></h3>

<p><code>list_length(Arg1) -> term()</code></p>
<p>Returns the number of element subtrees of a list skeleton.
  <code>Node</code> must represent a proper list. E.g., if
  <code>Node</code> represents "<code>[X1 | [X2, X3 | [X4, X5,
  X6]]]</code>", then <code>list_length(Node)</code> returns the
  integer 6.
 
  <p>Note: this is equivalent to
  <code>length(list_elements(Node))</code>, but potentially more
  efficient.</p>
 </p>
<p>See also: <a href="#is_proper_list-1"><code>is_proper_list/1</code></a>, <a href="#list-2"><code>list/2</code></a>, <a href="#list_elements-1"><code>list_elements/1</code></a>.</p>

<h3><a name="list_prefix-1">list_prefix/1</a></h3>

<p><code>list_prefix(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the prefix element subtrees of a <code>list</code> node.
  If <code>Node</code> represents "<code>[<em>E1</em>, ...,
  <em>En</em>]</code>" or "<code>[<em>E1</em>, ..., <em>En</em> |
  <em>Tail</em>]</code>", the returned value is <code>[E1, ...,
  En]</code>.
 </p>
<p>See also: <a href="#list-2"><code>list/2</code></a>.</p>

<h3><a name="list_suffix-1">list_suffix/1</a></h3>

<p><code>list_suffix(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the suffix subtree of a <code>list</code> node, if one
  exists. If <code>Node</code> represents "<code>[<em>E1</em>, ...,
  <em>En</em> | <em>Tail</em>]</code>", the returned value is
  <code>Tail</code>, otherwise, i.e., if <code>Node</code> represents
  "<code>[<em>E1</em>, ..., <em>En</em>]</code>", <code>none</code> is
  returned.
 
  <p>Note that even if this function returns some <code>Tail</code>
  that is not <code>none</code>, the type of <code>Tail</code> can be
  <code>nil</code>, if the tail has been given explicitly, and the list
  skeleton has not been compacted (cf.
  <code>compact_list/1</code>).</p>
 </p>
<p>See also: <a href="#compact_list-1"><code>compact_list/1</code></a>, <a href="#list-2"><code>list/2</code></a>, <a href="#nil-0"><code>nil/0</code></a>.</p>

<h3><a name="list_tail-1">list_tail/1</a></h3>

<p><code>list_tail(Arg1) -> term()</code></p>
<p>Returns the tail of a <code>list</code> node. If
  <code>Node</code> represents a single-element list
  "<code>[<em>E</em>]</code>", then the result has type
  <code>nil</code>, representing "<code>[]</code>". If
  <code>Node</code> represents "<code>[<em>E1</em>, <em>E2</em>
  ...]</code>", the result will represent "<code>[<em>E2</em>
  ...]</code>", and if <code>Node</code> represents
  "<code>[<em>Head</em> | <em>Tail</em>]</code>", the result will
  represent "<code><em>Tail</em></code>".
 </p>
<p>See also: <a href="#cons-2"><code>cons/2</code></a>, <a href="#list-2"><code>list/2</code></a>, <a href="#list_head-1"><code>list_head/1</code></a>.</p>

<h3><a name="macro-1">macro/1</a></h3>

<p><code>macro(Name) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#macro-2"><code>macro(Name, none)</code></a>.</p>

<h3><a name="macro-2">macro/2</a></h3>

<p><code>macro(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Arguments) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Arguments = none | [<a href="#type-syntaxTree">syntaxTree()</a>]</li></ul></code></p>
<p>Creates an abstract macro application. If <code>Arguments</code>
  is <code>none</code>, the result represents
  "<code>?<em>Name</em></code>", otherwise, if <code>Arguments</code>
  is <code>[A1, ..., An]</code>, the result represents
  "<code>?<em>Name</em>(<em>A1</em>, ..., <em>An</em>)</code>".
 
  <p>Notes: if <code>Arguments</code> is the empty list, the result
  will thus represent "<code>?<em>Name</em>()</code>", including a pair
  of matching parentheses.</p>
 
  <p>The only syntactical limitation imposed by the preprocessor on the
  arguments to a macro application (viewed as sequences of tokens) is
  that they must be balanced with respect to parentheses, brackets,
  <code>begin ... end</code>, <code>case ... end</code>, etc. The
  <code>text</code> node type can be used to represent arguments which
  are not regular Erlang constructs.</p>
 </p>
<p>See also: <a href="#macro-1"><code>macro/1</code></a>, <a href="#macro_arguments-1"><code>macro_arguments/1</code></a>, <a href="#macro_name-1"><code>macro_name/1</code></a>, <a href="#text-1"><code>text/1</code></a>.</p>

<h3><a name="macro_arguments-1">macro_arguments/1</a></h3>

<p><code>macro_arguments(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> none | [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of argument subtrees of a <code>macro</code>
  node, if any. If <code>Node</code> represents
  "<code>?<em>Name</em></code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents
  "<code>?<em>Name</em>(<em>A1</em>, ..., <em>An</em>)</code>",
  <code>[A1, ..., An]</code> is returned.
 </p>
<p>See also: <a href="#macro-2"><code>macro/2</code></a>.</p>

<h3><a name="macro_name-1">macro_name/1</a></h3>

<p><code>macro_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the name subtree of a <code>macro</code> node.
 </p>
<p>See also: <a href="#macro-2"><code>macro/2</code></a>.</p>

<h3><a name="make_tree-2">make_tree/2</a></h3>

<p><code>make_tree(Type::atom(), Groups::[[<a href="#type-syntaxTree">syntaxTree()</a>]]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates a syntax tree with the given type and subtrees.
  <code>Type</code> must be a node type name (cf. <code>type/1</code>)
  that does not denote a leaf node type (cf. <code>is_leaf/1</code>).
  <code>Groups</code> must be a <em>nonempty</em> list of groups of
  syntax trees, representing the subtrees of a node of the given type,
  in left-to-right order as they would occur in the printed program
  text, grouped by category as done by <code>subtrees/1</code>.
 
  <p>The result of <code>copy_attrs(Node, make_tree(type(Node),
  subtrees(Node)))</code> (cf. <code>update_tree/2</code>) represents
  the same source code text as the original <code>Node</code>, assuming
  that <code>subtrees(Node)</code> yields a nonempty list. However, it
  does not necessarily have the same data representation as
  <code>Node</code>.</p>
 </p>
<p>See also: <a href="#copy_attrs-2"><code>copy_attrs/2</code></a>, <a href="#is_leaf-1"><code>is_leaf/1</code></a>, <a href="#subtrees-1"><code>subtrees/1</code></a>, <a href="#type-1"><code>type/1</code></a>, <a href="#update_tree-1"><code>update_tree/1</code></a>.</p>

<h3><a name="match_expr-2">match_expr/2</a></h3>

<p><code>match_expr(Pattern::<a href="#type-syntaxTree">syntaxTree()</a>, Body::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract match-expression. The result represents
  "<code><em>Pattern</em> = <em>Body</em></code>".
 </p>
<p>See also: <a href="#match_expr_body-1"><code>match_expr_body/1</code></a>, <a href="#match_expr_pattern-1"><code>match_expr_pattern/1</code></a>.</p>

<h3><a name="match_expr_body-1">match_expr_body/1</a></h3>

<p><code>match_expr_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>match_expr</code> node.
 </p>
<p>See also: <a href="#match_expr-2"><code>match_expr/2</code></a>.</p>

<h3><a name="match_expr_pattern-1">match_expr_pattern/1</a></h3>

<p><code>match_expr_pattern(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the pattern subtree of a <code>match_expr</code> node.
 </p>
<p>See also: <a href="#match_expr-2"><code>match_expr/2</code></a>.</p>

<h3><a name="meta-1">meta/1</a></h3>

<p><code>meta(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates a meta-representation of a syntax tree. The result
  represents an Erlang expression "<code><em>MetaTree</em></code>"
  which, if evaluated, will yield a new syntax tree representing the
  same source code text as <code>Tree</code> (although the actual data
  representation may be different). The expression represented by
  <code>MetaTree</code> is <em>implementation independent</em> with
  regard to the data structures used by the abstract syntax tree
  implementation. Comments attached to nodes of <code>Tree</code> will
  be preserved, but other attributes are lost.
 
  <p>Any node in <code>Tree</code> whose node type is
  <code>variable</code> (cf. <code>type/1</code>), and whose list of
  annotations (cf. <code>get_ann/1</code>) contains the atom
  <code>meta_var</code>, will remain unchanged in the resulting tree,
  except that exactly one occurrence of <code>meta_var</code> is
  removed from its annotation list.</p>
 
  <p>The main use of the function <code>meta/1</code> is to transform a
  data structure <code>Tree</code>, which represents a piece of program
  code, into a form that is <em>representation independent when
  printed</em>. E.g., suppose <code>Tree</code> represents a variable
  named "V". Then (assuming a function <code>print/1</code> for
  printing syntax trees), evaluating <code>print(abstract(Tree))</code>
  - simply using <code>abstract/1</code> to map the actual data
  structure onto a syntax tree representation - would output a string
  that might look something like "<code>{tree, variable, ..., "V",
  ...}</code>", which is obviously dependent on the implementation of
  the abstract syntax trees. This could e.g. be useful for caching a
  syntax tree in a file. However, in some situations like in a program
  generator generator (with two "generator"), it may be unacceptable.
  Using <code>print(meta(Tree))</code> instead would output a
  <em>representation independent</em> syntax tree generating
  expression; in the above case, something like
  "<code>erl_syntax:variable("V")</code>".</p>
 </p>
<p>See also: <a href="#abstract-1"><code>abstract/1</code></a>, <a href="#get_ann-1"><code>get_ann/1</code></a>, <a href="#type-1"><code>type/1</code></a>.</p>

<h3><a name="module_qualifier-2">module_qualifier/2</a></h3>

<p><code>module_qualifier(Module::<a href="#type-syntaxTree">syntaxTree()</a>, Body::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract module qualifier. The result represents
  "<code><em>Module</em>:<em>Body</em></code>".
 </p>
<p>See also: <a href="#module_qualifier_argument-1"><code>module_qualifier_argument/1</code></a>, <a href="#module_qualifier_body-1"><code>module_qualifier_body/1</code></a>.</p>

<h3><a name="module_qualifier_argument-1">module_qualifier_argument/1</a></h3>

<p><code>module_qualifier_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument (the module) subtree of a
  <code>module_qualifier</code> node.
 </p>
<p>See also: <a href="#module_qualifier-2"><code>module_qualifier/2</code></a>.</p>

<h3><a name="module_qualifier_body-1">module_qualifier_body/1</a></h3>

<p><code>module_qualifier_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>module_qualifier</code>
  node.
 </p>
<p>See also: <a href="#module_qualifier-2"><code>module_qualifier/2</code></a>.</p>

<h3><a name="nil-0">nil/0</a></h3>

<p><code>nil() -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract empty list. The result represents
  "<code>[]</code>". The empty list is traditionally called "nil".
 </p>
<p>See also: <a href="#is_list_skeleton-1"><code>is_list_skeleton/1</code></a>, <a href="#list-2"><code>list/2</code></a>.</p>

<h3><a name="normalize_list-1">normalize_list/1</a></h3>

<p><code>normalize_list(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Expands an abstract list skeleton to its most explicit form. If
  <code>Node</code> represents "<code>[<em>E1</em>, ..., <em>En</em> |
  <em>Tail</em>]</code>", the result represents "<code>[<em>E1</em> |
  ... [<em>En</em> | <em>Tail1</em>] ... ]</code>", where
  <code>Tail1</code> is the result of
  <code>normalize_list(Tail)</code>. If <code>Node</code> represents
  "<code>[<em>E1</em>, ..., <em>En</em>]</code>", the result simply
  represents "<code>[<em>E1</em> | ... [<em>En</em> | []] ...
  ]</code>". If <code>Node</code> does not represent a list skeleton,
  <code>Node</code> itself is returned.
 </p>
<p>See also: <a href="#compact_list-1"><code>compact_list/1</code></a>, <a href="#list-2"><code>list/2</code></a>.</p>

<h3><a name="operator-1">operator/1</a></h3>

<p><code>operator(Name) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Name = atom() | string()</li></ul></code></p>
<p>Creates an abstract operator. The name of the operator is the
  character sequence represented by <code>Name</code>. This is
  analogous to the print name of an atom, but an operator is never
  written within single-quotes; e.g., the result of
  <code>operator('++')</code> represents "<code>++</code>" rather
  than "<code>'++'</code>".
 </p>
<p>See also: <a href="#atom-1"><code>atom/1</code></a>, <a href="#operator_literal-1"><code>operator_literal/1</code></a>, <a href="#operator_name-1"><code>operator_name/1</code></a>.</p>

<h3><a name="operator_literal-1">operator_literal/1</a></h3>

<p><code>operator_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the literal string represented by an
  <code>operator</code> node. This is simply the operator name as a
  string.
 </p>
<p>See also: <a href="#operator-1"><code>operator/1</code></a>.</p>

<h3><a name="operator_name-1">operator_name/1</a></h3>

<p><code>operator_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> atom()</code></p>
<p>Returns the name of an <code>operator</code> node. Note that
  the name is returned as an atom.
 </p>
<p>See also: <a href="#operator-1"><code>operator/1</code></a>.</p>

<h3><a name="parentheses-1">parentheses/1</a></h3>

<p><code>parentheses(Body::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract parenthesised expression. The result
  represents "<code>(<em>Body</em>)</code>", independently of the
  context.
 </p>
<p>See also: <a href="#parentheses_body-1"><code>parentheses_body/1</code></a>.</p>

<h3><a name="parentheses_body-1">parentheses_body/1</a></h3>

<p><code>parentheses_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>parentheses</code> node.
 </p>
<p>See also: <a href="#parentheses-1"><code>parentheses/1</code></a>.</p>

<h3><a name="prefix_expr-2">prefix_expr/2</a></h3>

<p><code>prefix_expr(Operator::<a href="#type-syntaxTree">syntaxTree()</a>, Argument::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract prefix operator expression. The result
  represents "<code><em>Operator</em> <em>Argument</em></code>".
 </p>
<p>See also: <a href="#infix_expr-3"><code>infix_expr/3</code></a>, <a href="#prefix_expr_argument-1"><code>prefix_expr_argument/1</code></a>, <a href="#prefix_expr_operator-1"><code>prefix_expr_operator/1</code></a>.</p>

<h3><a name="prefix_expr_argument-1">prefix_expr_argument/1</a></h3>

<p><code>prefix_expr_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument subtree of a <code>prefix_expr</code>
  node.
 </p>
<p>See also: <a href="#prefix_expr-2"><code>prefix_expr/2</code></a>.</p>

<h3><a name="prefix_expr_operator-1">prefix_expr_operator/1</a></h3>

<p><code>prefix_expr_operator(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the operator subtree of a <code>prefix_expr</code>
  node.
 </p>
<p>See also: <a href="#prefix_expr-2"><code>prefix_expr/2</code></a>.</p>

<h3><a name="query_expr-1">query_expr/1</a></h3>

<p><code>query_expr(Body::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract Mnemosyne query expression. The result
  represents "<code>query <em>Body</em> end</code>".
 </p>
<p>See also: <a href="#query_expr_body-1"><code>query_expr_body/1</code></a>, <a href="#record_access-2"><code>record_access/2</code></a>, <a href="#rule-2"><code>rule/2</code></a>.</p>

<h3><a name="query_expr_body-1">query_expr_body/1</a></h3>

<p><code>query_expr_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>query_expr</code> node.
 </p>
<p>See also: <a href="#query_expr-1"><code>query_expr/1</code></a>.</p>

<h3><a name="receive_expr-1">receive_expr/1</a></h3>

<p><code>receive_expr(Clauses) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#receive_expr-3"><code>receive_expr(Clauses, none, [])</code></a>.</p>

<h3><a name="receive_expr-3">receive_expr/3</a></h3>

<p><code>receive_expr(Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>], Timeout, Action::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Timeout = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract receive-expression. If <code>Timeout</code>
  is <code>none</code>, the result represents "<code>receive
  <em>C1</em>; ...; <em>Cn</em> end</code>" (the <code>Action</code>
  argument is ignored). Otherwise, if <code>Clauses</code> is
  <code>[C1, ..., Cn]</code> and <code>Action</code> is <code>[A1, ...,
  Am]</code>, the result represents "<code>receive <em>C1</em>; ...;
  <em>Cn</em> after <em>Timeout</em> -> <em>A1</em>, ..., <em>Am</em>
  end</code>". More exactly, if each <code>Ci</code> represents
  "<code>(<em>Pi</em>) <em>Gi</em> -> <em>Bi</em></code>", then the
  result represents "<code>receive <em>P1</em> <em>G1</em> ->
  <em>B1</em>; ...; <em>Pn</em> <em>Gn</em> -> <em>Bn</em> ...
  end</code>".
 
  <p>Note that in Erlang, a receive-expression must have at least one
  clause if no timeout part is specified.</p>
 </p>
<p>See also: <a href="#case_expr-2"><code>case_expr/2</code></a>, <a href="#clause-3"><code>clause/3</code></a>, <a href="#receive_expr-1"><code>receive_expr/1</code></a>, <a href="#receive_expr_action-1"><code>receive_expr_action/1</code></a>, <a href="#receive_expr_clauses-1"><code>receive_expr_clauses/1</code></a>, <a href="#receive_expr_timeout-1"><code>receive_expr_timeout/1</code></a>.</p>

<h3><a name="receive_expr_action-1">receive_expr_action/1</a></h3>

<p><code>receive_expr_action(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of action body subtrees of a
  <code>receive_expr</code> node. If <code>Node</code> represents
  "<code>receive <em>C1</em>; ...; <em>Cn</em> end</code>", this is the
  empty list.
 </p>
<p>See also: <a href="#receive_expr-3"><code>receive_expr/3</code></a>.</p>

<h3><a name="receive_expr_clauses-1">receive_expr_clauses/1</a></h3>

<p><code>receive_expr_clauses(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]<ul><li><a name="type-type">type(Node)</a> = receive_expr</li></ul></code></p>
<p>Returns the list of clause subtrees of a
  <code>receive_expr</code> node.
 </p>
<p>See also: <a href="#receive_expr-3"><code>receive_expr/3</code></a>.</p>

<h3><a name="receive_expr_timeout-1">receive_expr_timeout/1</a></h3>

<p><code>receive_expr_timeout(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> Timeout<ul><li>Timeout = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Returns the timeout subtree of a <code>receive_expr</code> node,
  if any. If <code>Node</code> represents "<code>receive <em>C1</em>;
  ...; <em>Cn</em> end</code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents "<code>receive
  <em>C1</em>; ...; <em>Cn</em> after <em>Timeout</em> -> <em>A1</em>,
  ..., <em>Am</em> end</code>", <code>[A1, ..., Am]</code> is returned.
 </p>
<p>See also: <a href="#receive_expr-3"><code>receive_expr/3</code></a>.</p>

<h3><a name="record_access-2">record_access/2</a></h3>

<p><code>record_access(Argument, Field) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#record_access-3"><code>record_access(Argument, none, Field)</code></a>.</p>

<h3><a name="record_access-3">record_access/3</a></h3>

<p><code>record_access(Argument::<a href="#type-syntaxTree">syntaxTree()</a>, Type, Field::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Type = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract record field access expression. If
  <code>Type</code> is <code>none</code>, the result represents
  simply "<code><em>Argument</em>.<em>Field</em></code>", otherwise
  it represents
  "<code><em>Argument</em>#<em>Type</em>.<em>Field</em></code>". (The
  first case is a special form only allowed within Mnemosyne
  queries.)
 </p>
<p>See also: <a href="#query_expr-1"><code>query_expr/1</code></a>, <a href="#record_access-2"><code>record_access/2</code></a>, <a href="#record_access_argument-1"><code>record_access_argument/1</code></a>, <a href="#record_access_field-1"><code>record_access_field/1</code></a>, <a href="#record_access_type-1"><code>record_access_type/1</code></a>, <a href="#record_expr-3"><code>record_expr/3</code></a>.</p>

<h3><a name="record_access_argument-1">record_access_argument/1</a></h3>

<p><code>record_access_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument subtree of a <code>record_access</code>
  node.
 </p>
<p>See also: <a href="#record_access-3"><code>record_access/3</code></a>.</p>

<h3><a name="record_access_field-1">record_access_field/1</a></h3>

<p><code>record_access_field(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the field subtree of a <code>record_access</code>
  node.
 </p>
<p>See also: <a href="#record_access-3"><code>record_access/3</code></a>.</p>

<h3><a name="record_access_type-1">record_access_type/1</a></h3>

<p><code>record_access_type(<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the type subtree of a <code>record_access</code> node,
  if any. If <code>Node</code> represents
  "<code><em>Argument</em>.<em>Field</em></code>", <code>none</code>
  is returned, otherwise if <code>Node</code> represents
  "<code><em>Argument</em>#<em>Type</em>.<em>Field</em></code>",
  <code>Type</code> is returned.
 </p>
<p>See also: <a href="#record_access-3"><code>record_access/3</code></a>.</p>

<h3><a name="record_expr-2">record_expr/2</a></h3>

<p><code>record_expr(Type, Fields) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#record_expr-3"><code>record_expr(none, Type, Fields)</code></a>.</p>

<h3><a name="record_expr-3">record_expr/3</a></h3>

<p><code>record_expr(Argument, Type::<a href="#type-syntaxTree">syntaxTree()</a>, Fields::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Argument = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract record expression. If <code>Fields</code> is
  <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is
  <code>none</code>, the result represents
  "<code>#<em>Type</em>{<em>F1</em>, ..., <em>Fn</em>}</code>",
  otherwise it represents
  "<code><em>Argument</em>#<em>Type</em>{<em>F1</em>, ...,
  <em>Fn</em>}</code>".
 </p>
<p>See also: <a href="#record_access-3"><code>record_access/3</code></a>, <a href="#record_expr-2"><code>record_expr/2</code></a>, <a href="#record_expr_argument-1"><code>record_expr_argument/1</code></a>, <a href="#record_expr_fields-1"><code>record_expr_fields/1</code></a>, <a href="#record_expr_type-1"><code>record_expr_type/1</code></a>, <a href="#record_field-2"><code>record_field/2</code></a>, <a href="#record_index_expr-2"><code>record_index_expr/2</code></a>.</p>

<h3><a name="record_expr_argument-1">record_expr_argument/1</a></h3>

<p><code>record_expr_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument subtree of a <code>record_expr</code> node,
  if any. If <code>Node</code> represents
  "<code>#<em>Type</em>{...}</code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents
  "<code><em>Argument</em>#<em>Type</em>{...}</code>",
  <code>Argument</code> is returned.
 </p>
<p>See also: <a href="#record_expr-3"><code>record_expr/3</code></a>.</p>

<h3><a name="record_expr_fields-1">record_expr_fields/1</a></h3>

<p><code>record_expr_fields(Arg1) -> term()</code></p>
<p>Returns the list of field subtrees of a
  <code>record_expr</code> node.
 </p>
<p>See also: <a href="#record_expr-3"><code>record_expr/3</code></a>.</p>

<h3><a name="record_expr_type-1">record_expr_type/1</a></h3>

<p><code>record_expr_type(Arg1) -> term()</code></p>
<p>Returns the type subtree of a <code>record_expr</code> node.
 </p>
<p>See also: <a href="#record_expr-3"><code>record_expr/3</code></a>.</p>

<h3><a name="record_field-1">record_field/1</a></h3>

<p><code>record_field(Name) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#record_field-2"><code>record_field(Name, none)</code></a>.</p>

<h3><a name="record_field-2">record_field/2</a></h3>

<p><code>record_field(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Value) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Value = none | <a href="#type-syntaxTree">syntaxTree()</a></li></ul></code></p>
<p>Creates an abstract record field specification. If
  <code>Value</code> is <code>none</code>, the result represents
  simply "<code><em>Name</em></code>", otherwise it represents
  "<code><em>Name</em> = <em>Value</em></code>".
 </p>
<p>See also: <a href="#record_expr-3"><code>record_expr/3</code></a>, <a href="#record_field_name-1"><code>record_field_name/1</code></a>, <a href="#record_field_value-1"><code>record_field_value/1</code></a>.</p>

<h3><a name="record_field_name-1">record_field_name/1</a></h3>

<p><code>record_field_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the name subtree of a <code>record_field</code> node.
 </p>
<p>See also: <a href="#record_field-2"><code>record_field/2</code></a>.</p>

<h3><a name="record_field_value-1">record_field_value/1</a></h3>

<p><code>record_field_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> none | <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the value subtree of a <code>record_field</code> node,
  if any. If <code>Node</code> represents
  "<code><em>Name</em></code>", <code>none</code> is
  returned. Otherwise, if <code>Node</code> represents
  "<code><em>Name</em> = <em>Value</em></code>", <code>Value</code>
  is returned.
 </p>
<p>See also: <a href="#record_field-2"><code>record_field/2</code></a>.</p>

<h3><a name="record_index_expr-2">record_index_expr/2</a></h3>

<p><code>record_index_expr(Type::<a href="#type-syntaxTree">syntaxTree()</a>, Field::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract record field index expression. The result
  represents "<code>#<em>Type</em>.<em>Field</em></code>".
 
  <p>(Note: the function name <code>record_index/2</code> is reserved
  by the Erlang compiler, which is why that name could not be used
  for this constructor.)</p>
 </p>
<p>See also: <a href="#record_expr-3"><code>record_expr/3</code></a>, <a href="#record_index_expr_field-1"><code>record_index_expr_field/1</code></a>, <a href="#record_index_expr_type-1"><code>record_index_expr_type/1</code></a>.</p>

<h3><a name="record_index_expr_field-1">record_index_expr_field/1</a></h3>

<p><code>record_index_expr_field(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the field subtree of a <code>record_index_expr</code>
  node.
 </p>
<p>See also: <a href="#record_index_expr-2"><code>record_index_expr/2</code></a>.</p>

<h3><a name="record_index_expr_type-1">record_index_expr_type/1</a></h3>

<p><code>record_index_expr_type(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the type subtree of a <code>record_index_expr</code>
  node.
 </p>
<p>See also: <a href="#record_index_expr-2"><code>record_index_expr/2</code></a>.</p>

<h3><a name="remove_comments-1">remove_comments/1</a></h3>

<p><code>remove_comments(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Clears the associated comments of <code>Node</code>.
 
  <p>Note: This is equivalent to
  <code>set_precomments(set_postcomments(Node, []), [])</code>, but
  potentially more efficient.</p>
 </p>
<p>See also: <a href="#set_postcomments-2"><code>set_postcomments/2</code></a>, <a href="#set_precomments-2"><code>set_precomments/2</code></a>.</p>

<h3><a name="revert-1">revert/1</a></h3>

<p><code>revert(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns an <code>erl_parse</code>-compatible representation of a
  syntax tree, if possible. If <code>Tree</code> represents a
  well-formed Erlang program or expression, the conversion should work
  without problems. There is however currently no way of detecting
  whether the operation succeeded; if it did not, then one or more
  subtrees of the result are not compatible with
  <code>erl_parse</code>.
 </p>
<p>See also: <a href="erl_parse.html"><code>erl_parse</code></a>, <a href="#revert_forms-1"><code>revert_forms/1</code></a>.</p>

<h3><a name="revert_forms-1">revert_forms/1</a></h3>

<p><code>revert_forms(Forms) -> error | [<a href="#type-erl_parse">erl_parse()</a>]<ul><li>Forms = <a href="#type-syntaxTree">syntaxTree()</a> | [<a href="#type-syntaxTree">syntaxTree()</a>]</li></ul></code></p>
<p>Reverts a sequence of Erlang source code forms. The sequence can
  be given either as a <code>form_list</code> syntax tree (possibly
  nested), or as a list of "program form" syntax trees. If successful,
  the corresponding flat list of <code>erl_parse</code>-compatible
  syntax trees is returned (cf. <code>revert/1</code>), otherwise, if
  some program form could not be reverted, <code>error</code> is
  returned. Standalone comments in the sequence of forms are
  automatically ignored and discarded.
 </p>
<p>See also: <a href="#form_list-1"><code>form_list/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#revert-1"><code>revert/1</code></a>.</p>

<h3><a name="rule-2">rule/2</a></h3>

<p><code>rule(Name::<a href="#type-syntaxTree">syntaxTree()</a>, Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract Mnemosyne rule. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the results represents
  "<code><em>Name</em> <em>C1</em>; ...; <em>Name</em>
  <em>Cn</em>.</code>". More exactly, if each <code>Ci</code>
  represents "<code>(<em>Pi1</em>, ..., <em>Pim</em>) <em>Gi</em> ->
  <em>Bi</em></code>", then the result represents
  "<code><em>Name</em>(<em>P11</em>, ..., <em>P1m</em>) <em>G1</em> :-
  <em>B1</em>; ...; <em>Name</em>(<em>Pn1</em>, ..., <em>Pnm</em>)
  <em>Gn</em> :- <em>Bn</em>.</code>". Rules are source code forms.
 </p>
<p>See also: <a href="#function-2"><code>function/2</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#rule_arity-1"><code>rule_arity/1</code></a>, <a href="#rule_clauses-1"><code>rule_clauses/1</code></a>, <a href="#rule_name-1"><code>rule_name/1</code></a>.</p>

<h3><a name="rule_arity-1">rule_arity/1</a></h3>

<p><code>rule_arity(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> integer()</code></p>
<p>Returns the arity of a <code>rule</code> node. The result is the
  number of parameter patterns in the first clause of the rule;
  subsequent clauses are ignored.
 
  <p>An exception is thrown if <code>rule_clauses(Node)</code> returns
  an empty list, or if the first element of that list is not a syntax
  tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 </p>
<p>See also: <a href="#clause-3"><code>clause/3</code></a>, <a href="#clause_patterns-1"><code>clause_patterns/1</code></a>, <a href="#rule-2"><code>rule/2</code></a>, <a href="#rule_clauses-1"><code>rule_clauses/1</code></a>.</p>

<h3><a name="rule_clauses-1">rule_clauses/1</a></h3>

<p><code>rule_clauses(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of clause subtrees of a <code>rule</code> node.
 </p>
<p>See also: <a href="#rule-2"><code>rule/2</code></a>.</p>

<h3><a name="rule_name-1">rule_name/1</a></h3>

<p><code>rule_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the name subtree of a <code>rule</code> node.
 </p>
<p>See also: <a href="#rule-2"><code>rule/2</code></a>.</p>

<h3><a name="set_ann-2">set_ann/2</a></h3>

<p><code>set_ann(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Annotations::[term()]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Sets the list of user annotations of <code>Node</code> to
  <code>Annotations</code>.
 </p>
<p>See also: <a href="#add_ann-2"><code>add_ann/2</code></a>, <a href="#copy_ann-2"><code>copy_ann/2</code></a>, <a href="#get_ann-1"><code>get_ann/1</code></a>.</p>

<h3><a name="set_attrs-2">set_attrs/2</a></h3>

<p><code>set_attrs(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Attributes::<a href="#type-syntaxTreeAttributes">syntaxTreeAttributes()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Sets the attributes of <code>Node</code> to
  <code>Attributes</code>.
 </p>
<p>See also: <a href="#copy_attrs-2"><code>copy_attrs/2</code></a>, <a href="#get_attrs-1"><code>get_attrs/1</code></a>, <a href="#set_attrs-2"><code>set_attrs/2</code></a>.</p>

<h3><a name="set_pos-2">set_pos/2</a></h3>

<p><code>set_pos(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Pos::term()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Sets the position information of <code>Node</code> to
  <code>Pos</code>.
 </p>
<p>See also: <a href="#copy_pos-2"><code>copy_pos/2</code></a>, <a href="#get_pos-1"><code>get_pos/1</code></a>.</p>

<h3><a name="set_postcomments-2">set_postcomments/2</a></h3>

<p><code>set_postcomments(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Comments::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Sets the post-comments of <code>Node</code> to
  <code>Comments</code>. <code>Comments</code> should be a possibly
  empty list of abstract comments, in top-down textual order
 </p>
<p>See also: <a href="#add_postcomments-2"><code>add_postcomments/2</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_postcomments-1"><code>get_postcomments/1</code></a>, <a href="#set_precomments-2"><code>set_precomments/2</code></a>.</p>

<h3><a name="set_precomments-2">set_precomments/2</a></h3>

<p><code>set_precomments(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Comments::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Sets the pre-comments of <code>Node</code> to
  <code>Comments</code>. <code>Comments</code> should be a possibly
  empty list of abstract comments, in top-down textual order.
 </p>
<p>See also: <a href="#add_precomments-2"><code>add_precomments/2</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#get_precomments-1"><code>get_precomments/1</code></a>, <a href="#set_postcomments-2"><code>set_postcomments/2</code></a>.</p>

<h3><a name="size_qualifier-2">size_qualifier/2</a></h3>

<p><code>size_qualifier(Body::<a href="#type-syntaxTree">syntaxTree()</a>, Size::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract size qualifier. The result represents
  "<code><em>Body</em>:<em>Size</em></code>".
 </p>
<p>See also: <a href="#size_qualifier_argument-1"><code>size_qualifier_argument/1</code></a>, <a href="#size_qualifier_body-1"><code>size_qualifier_body/1</code></a>.</p>

<h3><a name="size_qualifier_argument-1">size_qualifier_argument/1</a></h3>

<p><code>size_qualifier_argument(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the argument subtree (the size) of a
  <code>size_qualifier</code> node.
 </p>
<p>See also: <a href="#size_qualifier-2"><code>size_qualifier/2</code></a>.</p>

<h3><a name="size_qualifier_body-1">size_qualifier_body/1</a></h3>

<p><code>size_qualifier_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>size_qualifier</code>
  node.
 </p>
<p>See also: <a href="#size_qualifier-2"><code>size_qualifier/2</code></a>.</p>

<h3><a name="string-1">string/1</a></h3>

<p><code>string(Value::string()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract string literal. The result represents
  <code>"<em>Text</em>"</code> (including the surrounding
  double-quotes), where <code>Text</code> corresponds to the sequence
  of characters in <code>Value</code>, but not representing a
  <em>specific</em> string literal. E.g., the result of
  <code>string("x\ny")</code> represents any and all of
  <code>"x\ny"</code>, <code>"x\12y"</code>, <code>"x\012y"</code> and
  <code>"x\^Jy"</code>; cf. <code>char/1</code>.
 </p>
<p>See also: <a href="#char-1"><code>char/1</code></a>, <a href="#is_string-2"><code>is_string/2</code></a>, <a href="#string_literal-1"><code>string_literal/1</code></a>, <a href="#string_value-1"><code>string_value/1</code></a>.</p>

<h3><a name="string_literal-1">string_literal/1</a></h3>

<p><code>string_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the literal string represented by a <code>string</code>
  node. This includes surrounding double-quote characters.
 </p>
<p>See also: <a href="#string-1"><code>string/1</code></a>.</p>

<h3><a name="string_value-1">string_value/1</a></h3>

<p><code>string_value(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the value represented by a <code>string</code> node.
 </p>
<p>See also: <a href="#string-1"><code>string/1</code></a>.</p>

<h3><a name="subtrees-1">subtrees/1</a></h3>

<p><code>subtrees(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> [[<a href="#type-syntaxTree">syntaxTree()</a>]]</code></p>
<p>Returns the grouped list of all subtrees of a syntax tree. If
  <code>Node</code> is a leaf node (cf. <code>is_leaf/1</code>), this
  is the empty list, otherwise the result is always a nonempty list,
  containing the lists of subtrees of <code>Node</code>, in
  left-to-right order as they occur in the printed program text, and
  grouped by category. Often, each group contains only a single
  subtree.
 
  <p>Depending on the type of <code>Node</code>, the size of some
  groups may be variable (e.g., the group consisting of all the
  elements of a tuple), while others always contain the same number of
  elements - usually exactly one (e.g., the group containing the
  argument expression of a case-expression). Note, however, that the
  exact structure of the returned list (for a given node type) should
  in general not be depended upon, since it might be subject to change
  without notice.</p>
 
  <p>The function <code>subtrees/1</code> and the constructor functions
  <code>make_tree/2</code> and <code>update_tree/2</code> can be a
  great help if one wants to traverse a syntax tree, visiting all its
  subtrees, but treat nodes of the tree in a uniform way in most or all
  cases. Using these functions makes this simple, and also assures that
  your code is not overly sensitive to extensions of the syntax tree
  data type, because any node types not explicitly handled by your code
  can be left to a default case.</p>
 
  <p>For example:
  <pre>
    postorder(F, Tree) ->
        F(case subtrees(Tree) of
            [] -> Tree;
            List -> update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &lt;- Group]
                                 || Group &lt;- List])
          end).
  </pre>
  maps the function <code>F</code> on <code>Tree</code> and all its
  subtrees, doing a post-order traversal of the syntax tree. (Note the
  use of <code>update_tree/2</code> to preserve node attributes.) For a
  simple function like:
  <pre>
    f(Node) ->
        case type(Node) of
            atom -> atom("a_" ++ atom_name(Node));
            _ -> Node
        end.
  </pre>
  the call <code>postorder(fun f/1, Tree)</code> will yield a new
  representation of <code>Tree</code> in which all atom names have been
  extended with the prefix "a_", but nothing else (including comments,
  annotations and line numbers) has been changed.</p>
 </p>
<p>See also: <a href="#copy_attrs-2"><code>copy_attrs/2</code></a>, <a href="#is_leaf-1"><code>is_leaf/1</code></a>, <a href="#make_tree-2"><code>make_tree/2</code></a>, <a href="#type-1"><code>type/1</code></a>.</p>

<h3><a name="text-1">text/1</a></h3>

<p><code>text(String::string()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract piece of source code text. The result
  represents exactly the sequence of characters in <code>String</code>.
  This is useful in cases when one wants full control of the resulting
  output, e.g., for the appearance of floating-point numbers or macro
  definitions.
 </p>
<p>See also: <a href="#text_string-1"><code>text_string/1</code></a>.</p>

<h3><a name="text_string-1">text_string/1</a></h3>

<p><code>text_string(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the character sequence represented by a
  <code>text</code> node.
 </p>
<p>See also: <a href="#text-1"><code>text/1</code></a>.</p>

<h3><a name="tree-1">tree/1</a></h3>

<p><code>tree(Type) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Equivalent to <a href="#tree-2"><code>tree(Type, [])</code></a>.</p>

<h3><a name="tree-2">tree/2</a></h3>

<p><code>tree(Type::atom(), Data::term()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p><em>For special purposes only</em>. Creates an abstract syntax
  tree node with type tag <code>Type</code> and associated data
  <code>Data</code>.
 
  <p>This function and the related <code>is_tree/1</code> and
  <code>data/1</code> provide a uniform way to extend the set of
  <code>erl_parse</code> node types. The associated data is any term,
  whose format may depend on the type tag.</p>
 
  <h4>Notes:</h4>
  <ul>
   <li>Any nodes created outside of this module must have type tags
       distinct from those currently defined by this module; see
       <code>type</code> for a complete list.</li>
   <li>The type tag of a syntax tree node may also be used
       as a primary tag by the <code>erl_parse</code> representation;
       in that case, the selector functions for that node type
       <em>must</em> handle both the abstract syntax tree and the
       <code>erl_parse</code> form. The function <code>type(T)</code>
       should return the correct type tag regardless of the
       representation of <code>T</code>, so that the user sees no
       difference between <code>erl_syntax</code> and
       <code>erl_parse</code> nodes.</li>
  </ul></p>
<p>See also: <a href="#data-1"><code>data/1</code></a>, <a href="#is_tree-1"><code>is_tree/1</code></a>, <a href="#type-1"><code>type/1</code></a>.</p>

<h3><a name="try_expr-2">try_expr/2</a></h3>

<p><code>try_expr(Body::<a href="#type-syntaxTree">syntaxTree()</a>, Clauses::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract try-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>try
  <em>Body</em> catch <em>C1</em>; ...; <em>Cn</em> end</code>". More
  exactly, if each <code>Ci</code> represents "<code>(<em>Pi</em>)
  <em>Gi</em> -> <em>Bi</em></code>", then the result represents
  "<code>try <em>Body</em> catch <em>P1</em> <em>G1</em> ->
  <em>B1</em>; ...; <em>Pn</em> <em>Gn</em> -> <em>Bn</em> end</code>".
 
  <p>Note: try-expressions are not yet part of the Erlang language, and
  the syntax is not final.</p>
 </p>
<p>See also: <a href="#case_expr-2"><code>case_expr/2</code></a>, <a href="#clause-3"><code>clause/3</code></a>, <a href="#try_expr_body-1"><code>try_expr_body/1</code></a>, <a href="#try_expr_clauses-1"><code>try_expr_clauses/1</code></a>.</p>

<h3><a name="try_expr_body-1">try_expr_body/1</a></h3>

<p><code>try_expr_body(<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Returns the body subtree of a <code>try_expr</code> node.
 </p>
<p>See also: <a href="#try_expr-2"><code>try_expr/2</code></a>.</p>

<h3><a name="try_expr_clauses-1">try_expr_clauses/1</a></h3>

<p><code>try_expr_clauses(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of clause subtrees of a <code>try_expr</code>
  node.
 </p>
<p>See also: <a href="#try_expr-2"><code>try_expr/2</code></a>.</p>

<h3><a name="tuple-1">tuple/1</a></h3>

<p><code>tuple(Elements::[<a href="#type-syntaxTree">syntaxTree()</a>]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract tuple. If <code>Elements</code> is
  <code>[X1, ..., Xn]</code>, the result represents
  "<code>{<em>X1</em>, ..., <em>Xn</em>}</code>".
 
  <p>Note: The Erlang language has distinct 1-tuples, i.e.,
  <code>{X}</code> is always distinct from <code>X</code> itself.</p>
 </p>
<p>See also: <a href="#tuple_elements-1"><code>tuple_elements/1</code></a>, <a href="#tuple_size-1"><code>tuple_size/1</code></a>.</p>

<h3><a name="tuple_elements-1">tuple_elements/1</a></h3>

<p><code>tuple_elements(<a href="#type-syntaxTree">syntaxTree()</a>) -> [<a href="#type-syntaxTree">syntaxTree()</a>]</code></p>
<p>Returns the list of element subtrees of a <code>tuple</code>
  node.
 </p>
<p>See also: <a href="#tuple-1"><code>tuple/1</code></a>.</p>

<h3><a name="tuple_size-1">tuple_size/1</a></h3>

<p><code>tuple_size(<a href="#type-syntaxTree">syntaxTree()</a>) -> integer()</code></p>
<p>Returns the number of elements of a <code>tuple</code> node.
 
  <p>Note: this is equivalent to
  <code>length(tuple_elements(Node))</code>, but potentially more
  efficient.</p>
 </p>
<p>See also: <a href="#tuple-1"><code>tuple/1</code></a>, <a href="#tuple_elements-1"><code>tuple_elements/1</code></a>.</p>

<h3><a name="type-1">type/1</a></h3>

<p><code>type(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> atom()</code></p>
<p>Returns the type tag of <code>Node</code>. If <code>Node</code>
  does not represent a syntax tree, evaluation fails with reason
  <code>badarg</code>. Node types currently defined by this module are:
  <p><center><table border="1">
   <tr>
    <td>application</td>
    <td>arity_qualifier</td>
    <td>atom</td>
    <td>attribute</td>
    <td>binary</td>
   </tr><tr>
    <td>binary_field</td>
    <td>block_expr</td>
    <td>case_expr</td>
    <td>catch_expr</td>
    <td>char</td>
   </tr><tr>
    <td>clause</td>
    <td>comment</td>
    <td>conjunction</td>
    <td>disjunction</td>
    <td>eof_marker</td>
   </tr><tr>
    <td>error_marker</td>
    <td>float</td>
    <td>form_list</td>
    <td>fun_expr</td>
    <td>function</td>
   </tr><tr>
    <td>generator</td>
    <td>if_expr</td>
    <td>implicit_fun</td>
    <td>infix_expr</td>
    <td>integer</td>
   </tr><tr>
    <td>list</td>
    <td>list_comp</td>
    <td>macro</td>
    <td>match_expr</td>
    <td>module_qualifier</td>
   </tr><tr>
    <td>nil</td>
    <td>operator</td>
    <td>parentheses</td>
    <td>prefix_expr</td>
    <td>query_expr</td>
   </tr><tr>
    <td>receive_expr</td>
    <td>record_access</td>
    <td>record_expr</td>
    <td>record_field</td>
    <td>record_index_expr</td>
   </tr><tr>
    <td>rule</td>
    <td>size_qualifier</td>
    <td>string</td>
    <td>text</td>
    <td>try_expr</td>
   </tr><tr>
    <td>tuple</td>
    <td>underscore</td>
    <td>variable</td>
    <td>warning_marker</td>
   </tr>
  </table></center></p>
  <p>The user may (for special purposes) create additional nodes
  with other type tags, using the <code>tree/2</code> function.</p>
 
  <p>Note: The primary constructor functions for a node type should
  always have the same name as the node type itself.</p>
 </p>
<p>See also: <a href="#application-3"><code>application/3</code></a>, <a href="#arity_qualifier-2"><code>arity_qualifier/2</code></a>, <a href="#atom-1"><code>atom/1</code></a>, <a href="#attribute-2"><code>attribute/2</code></a>, <a href="#binary-1"><code>binary/1</code></a>, <a href="#binary_field-2"><code>binary_field/2</code></a>, <a href="#block_expr-1"><code>block_expr/1</code></a>, <a href="#case_expr-2"><code>case_expr/2</code></a>, <a href="#catch_expr-1"><code>catch_expr/1</code></a>, <a href="#char-1"><code>char/1</code></a>, <a href="#clause-3"><code>clause/3</code></a>, <a href="#comment-2"><code>comment/2</code></a>, <a href="#conjunction-1"><code>conjunction/1</code></a>, <a href="#disjunction-1"><code>disjunction/1</code></a>, <a href="#eof_marker-0"><code>eof_marker/0</code></a>, <a href="#error_marker-1"><code>error_marker/1</code></a>, <a href="#float-1"><code>float/1</code></a>, <a href="#form_list-1"><code>form_list/1</code></a>, <a href="#fun_expr-1"><code>fun_expr/1</code></a>, <a href="#function-2"><code>function/2</code></a>, <a href="#generator-2"><code>generator/2</code></a>, <a href="#if_expr-1"><code>if_expr/1</code></a>, <a href="#implicit_fun-2"><code>implicit_fun/2</code></a>, <a href="#infix_expr-3"><code>infix_expr/3</code></a>, <a href="#integer-1"><code>integer/1</code></a>, <a href="#list-2"><code>list/2</code></a>, <a href="#list_comp-2"><code>list_comp/2</code></a>, <a href="#macro-2"><code>macro/2</code></a>, <a href="#match_expr-2"><code>match_expr/2</code></a>, <a href="#module_qualifier-2"><code>module_qualifier/2</code></a>, <a href="#nil-0"><code>nil/0</code></a>, <a href="#operator-1"><code>operator/1</code></a>, <a href="#parentheses-1"><code>parentheses/1</code></a>, <a href="#prefix_expr-2"><code>prefix_expr/2</code></a>, <a href="#query_expr-1"><code>query_expr/1</code></a>, <a href="#receive_expr-3"><code>receive_expr/3</code></a>, <a href="#record_access-3"><code>record_access/3</code></a>, <a href="#record_expr-2"><code>record_expr/2</code></a>, <a href="#record_field-2"><code>record_field/2</code></a>, <a href="#record_index_expr-2"><code>record_index_expr/2</code></a>, <a href="#rule-2"><code>rule/2</code></a>, <a href="#size_qualifier-2"><code>size_qualifier/2</code></a>, <a href="#string-1"><code>string/1</code></a>, <a href="#text-1"><code>text/1</code></a>, <a href="#tree-2"><code>tree/2</code></a>, <a href="#try_expr-2"><code>try_expr/2</code></a>, <a href="#tuple-1"><code>tuple/1</code></a>, <a href="#underscore-0"><code>underscore/0</code></a>, <a href="#variable-1"><code>variable/1</code></a>, <a href="#warning_marker-1"><code>warning_marker/1</code></a>.</p>

<h3><a name="underscore-0">underscore/0</a></h3>

<p><code>underscore() -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract universal pattern ("<code>_</code>"). The
  lexical representation is a single underscore character. Note that
  this is <em>not</em> a variable, lexically speaking.
 </p>
<p>See also: <a href="#variable-1"><code>variable/1</code></a>.</p>

<h3><a name="update_tree-2">update_tree/2</a></h3>

<p><code>update_tree(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Groups::[[<a href="#type-syntaxTree">syntaxTree()</a>]]) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates a syntax tree with the same type and attributes as the
  given tree. This is equivalent to <code>copy_attrs(Node,
  make_tree(type(Node), Groups))</code>.
 </p>
<p>See also: <a href="#copy_attrs-2"><code>copy_attrs/2</code></a>, <a href="#make_tree-2"><code>make_tree/2</code></a>, <a href="#type-1"><code>type/1</code></a>.</p>

<h3><a name="variable-1">variable/1</a></h3>

<p><code>variable(Name) -> <a href="#type-syntaxTree">syntaxTree()</a><ul><li>Name = atom() | string()</li></ul></code></p>
<p>Creates an abstract variable with the given name.
  <code>Name</code> may be any atom or string that represents a
  lexically valid variable name, but <em>not</em> a single underscore
  character; cf. <code>underscore/0</code>.
 
  <p>Note: no checking is done whether the character sequence
  represents a proper variable name, i.e., whether or not its first
  character is an uppercase Erlang character, or whether it does not
  contain control characters, whitespace, etc.</p>
 </p>
<p>See also: <a href="#underscore-0"><code>underscore/0</code></a>, <a href="#variable_literal-1"><code>variable_literal/1</code></a>, <a href="#variable_name-1"><code>variable_name/1</code></a>.</p>

<h3><a name="variable_literal-1">variable_literal/1</a></h3>

<p><code>variable_literal(<a href="#type-syntaxTree">syntaxTree()</a>) -> string()</code></p>
<p>Returns the name of a <code>variable</code> node as a string.
 </p>
<p>See also: <a href="#variable-1"><code>variable/1</code></a>.</p>

<h3><a name="variable_name-1">variable_name/1</a></h3>

<p><code>variable_name(<a href="#type-syntaxTree">syntaxTree()</a>) -> atom()</code></p>
<p>Returns the name of a <code>variable</code> node as an atom.
 </p>
<p>See also: <a href="#variable-1"><code>variable/1</code></a>.</p>

<h3><a name="warning_marker-1">warning_marker/1</a></h3>

<p><code>warning_marker(Error::term()) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates an abstract warning marker. The result represents an
  occurrence of a possible problem in the source code, with an
  associated Erlang I/O ErrorInfo structure given by <code>Error</code>
  (see module <code>io</code> for details). Warning markers are
  regarded as source code forms, but have no defined lexical form.
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.</p>
 </p>
<p>See also: <a href="io.html"><code>io</code></a>, <a href="#eof_marker-0"><code>eof_marker/0</code></a>, <a href="#error_marker-1"><code>error_marker/1</code></a>, <a href="#is_form-1"><code>is_form/1</code></a>, <a href="#warning_marker_info-1"><code>warning_marker_info/1</code></a>.</p>

<h3><a name="warning_marker_info-1">warning_marker_info/1</a></h3>

<p><code>warning_marker_info(<a href="#type-syntaxTree">syntaxTree()</a>) -> term()</code></p>
<p>Returns the ErrorInfo structure of a <code>warning_marker</code>
  node.
 </p>
<p>See also: <a href="#warning_marker-1"><code>warning_marker/1</code></a>.</p>

<h2><a name="internal">Documented Internal Functions</a></h2>

<h3><a name="is_wrapper-1">is_wrapper/1</a></h3>

<p><code>is_wrapper(Term::term()) -> bool()</code></p>
<p>Returns <code>true</code> if the argument is a wrapper
  structure, otherwise <code>false</code>.</p>

<h3><a name="unwrap-1">unwrap/1</a></h3>

<p><code>unwrap(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Removes any wrapper structure, if present. If <code>Node</code>
  is a wrapper structure, this function returns the wrapped
  <code>erl_parse</code> tree; otherwise it returns <code>Node</code>
  itself.</p>

<h3><a name="wrap-1">wrap/1</a></h3>

<p><code>wrap(Node::<a href="#type-erl_parse">erl_parse()</a>) -> <a href="#type-syntaxTree">syntaxTree()</a></code></p>
<p>Creates a wrapper structure around an <code>erl_parse</code>
  "parse tree".
 
  <p>This function and the related <code>unwrap/1</code> and
  <code>is_wrapper/1</code> provide a uniform way to attach arbitrary
  information to an <code>erl_parse</code> tree. Some information about
  the encapsuled tree may be cached in the wrapper, such as the node
  type. All functions on syntax trees must behave so that the user sees
  no difference between wrapped and non-wrapped <code>erl_parse</code>
  trees. <em>Attaching a wrapper onto another wrapper structure is an
  error</em>.</p></p></body>
</html>